// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file gastrolog/v1/vault.proto (package gastrolog.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message gastrolog.v1.ListVaultsRequest
 */
export class ListVaultsRequest extends Message<ListVaultsRequest> {
  constructor(data?: PartialMessage<ListVaultsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListVaultsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVaultsRequest {
    return new ListVaultsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVaultsRequest {
    return new ListVaultsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVaultsRequest {
    return new ListVaultsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListVaultsRequest | PlainMessage<ListVaultsRequest> | undefined, b: ListVaultsRequest | PlainMessage<ListVaultsRequest> | undefined): boolean {
    return proto3.util.equals(ListVaultsRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListVaultsResponse
 */
export class ListVaultsResponse extends Message<ListVaultsResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.VaultInfo vaults = 1;
   */
  vaults: VaultInfo[] = [];

  constructor(data?: PartialMessage<ListVaultsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListVaultsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vaults", kind: "message", T: VaultInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVaultsResponse {
    return new ListVaultsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVaultsResponse {
    return new ListVaultsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVaultsResponse {
    return new ListVaultsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListVaultsResponse | PlainMessage<ListVaultsResponse> | undefined, b: ListVaultsResponse | PlainMessage<ListVaultsResponse> | undefined): boolean {
    return proto3.util.equals(ListVaultsResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.VaultInfo
 */
export class VaultInfo extends Message<VaultInfo> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: string filter = 3;
   */
  filter = "";

  /**
   * @generated from field: int64 chunk_count = 4;
   */
  chunkCount = protoInt64.zero;

  /**
   * @generated from field: int64 record_count = 5;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: bool enabled = 6;
   */
  enabled = false;

  /**
   * @generated from field: string name = 7;
   */
  name = "";

  /**
   * @generated from field: string node_id = 8;
   */
  nodeId = "";

  /**
   * True if vault lives on another node
   *
   * @generated from field: bool remote = 9;
   */
  remote = false;

  constructor(data?: PartialMessage<VaultInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.VaultInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "chunk_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "remote", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultInfo {
    return new VaultInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultInfo {
    return new VaultInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultInfo {
    return new VaultInfo().fromJsonString(jsonString, options);
  }

  static equals(a: VaultInfo | PlainMessage<VaultInfo> | undefined, b: VaultInfo | PlainMessage<VaultInfo> | undefined): boolean {
    return proto3.util.equals(VaultInfo, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetVaultRequest
 */
export class GetVaultRequest extends Message<GetVaultRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetVaultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetVaultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVaultRequest {
    return new GetVaultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVaultRequest {
    return new GetVaultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVaultRequest {
    return new GetVaultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetVaultRequest | PlainMessage<GetVaultRequest> | undefined, b: GetVaultRequest | PlainMessage<GetVaultRequest> | undefined): boolean {
    return proto3.util.equals(GetVaultRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetVaultResponse
 */
export class GetVaultResponse extends Message<GetVaultResponse> {
  /**
   * @generated from field: gastrolog.v1.VaultInfo vault = 1;
   */
  vault?: VaultInfo;

  constructor(data?: PartialMessage<GetVaultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetVaultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "message", T: VaultInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVaultResponse {
    return new GetVaultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVaultResponse {
    return new GetVaultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVaultResponse {
    return new GetVaultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetVaultResponse | PlainMessage<GetVaultResponse> | undefined, b: GetVaultResponse | PlainMessage<GetVaultResponse> | undefined): boolean {
    return proto3.util.equals(GetVaultResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListChunksRequest
 */
export class ListChunksRequest extends Message<ListChunksRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  constructor(data?: PartialMessage<ListChunksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListChunksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListChunksRequest | PlainMessage<ListChunksRequest> | undefined, b: ListChunksRequest | PlainMessage<ListChunksRequest> | undefined): boolean {
    return proto3.util.equals(ListChunksRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListChunksResponse
 */
export class ListChunksResponse extends Message<ListChunksResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkMeta chunks = 1;
   */
  chunks: ChunkMeta[] = [];

  constructor(data?: PartialMessage<ListChunksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListChunksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks", kind: "message", T: ChunkMeta, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListChunksResponse | PlainMessage<ListChunksResponse> | undefined, b: ListChunksResponse | PlainMessage<ListChunksResponse> | undefined): boolean {
    return proto3.util.equals(ListChunksResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkMeta
 */
export class ChunkMeta extends Message<ChunkMeta> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: google.protobuf.Timestamp start_ts = 2;
   */
  startTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_ts = 3;
   */
  endTs?: Timestamp;

  /**
   * @generated from field: bool sealed = 4;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 5;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: int64 bytes = 6;
   */
  bytes = protoInt64.zero;

  /**
   * true if raw.log/attr.log are compressed
   *
   * @generated from field: bool compressed = 7;
   */
  compressed = false;

  /**
   * actual on-disk size (may differ from bytes if compressed)
   *
   * @generated from field: int64 disk_bytes = 8;
   */
  diskBytes = protoInt64.zero;

  constructor(data?: PartialMessage<ChunkMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_ts", kind: "message", T: Timestamp },
    { no: 3, name: "end_ts", kind: "message", T: Timestamp },
    { no: 4, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "compressed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "disk_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkMeta {
    return new ChunkMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkMeta {
    return new ChunkMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkMeta {
    return new ChunkMeta().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkMeta | PlainMessage<ChunkMeta> | undefined, b: ChunkMeta | PlainMessage<ChunkMeta> | undefined): boolean {
    return proto3.util.equals(ChunkMeta, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetChunkRequest
 */
export class GetChunkRequest extends Message<GetChunkRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  /**
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<GetChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChunkRequest | PlainMessage<GetChunkRequest> | undefined, b: GetChunkRequest | PlainMessage<GetChunkRequest> | undefined): boolean {
    return proto3.util.equals(GetChunkRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetChunkResponse
 */
export class GetChunkResponse extends Message<GetChunkResponse> {
  /**
   * @generated from field: gastrolog.v1.ChunkMeta chunk = 1;
   */
  chunk?: ChunkMeta;

  constructor(data?: PartialMessage<GetChunkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetChunkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk", kind: "message", T: ChunkMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChunkResponse | PlainMessage<GetChunkResponse> | undefined, b: GetChunkResponse | PlainMessage<GetChunkResponse> | undefined): boolean {
    return proto3.util.equals(GetChunkResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetIndexesRequest
 */
export class GetIndexesRequest extends Message<GetIndexesRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  /**
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<GetIndexesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetIndexesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIndexesRequest | PlainMessage<GetIndexesRequest> | undefined, b: GetIndexesRequest | PlainMessage<GetIndexesRequest> | undefined): boolean {
    return proto3.util.equals(GetIndexesRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetIndexesResponse
 */
export class GetIndexesResponse extends Message<GetIndexesResponse> {
  /**
   * @generated from field: bool sealed = 1;
   */
  sealed = false;

  /**
   * @generated from field: repeated gastrolog.v1.IndexInfo indexes = 2;
   */
  indexes: IndexInfo[] = [];

  constructor(data?: PartialMessage<GetIndexesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetIndexesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "indexes", kind: "message", T: IndexInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIndexesResponse | PlainMessage<GetIndexesResponse> | undefined, b: GetIndexesResponse | PlainMessage<GetIndexesResponse> | undefined): boolean {
    return proto3.util.equals(GetIndexesResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.IndexInfo
 */
export class IndexInfo extends Message<IndexInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: bool exists = 2;
   */
  exists = false;

  /**
   * @generated from field: int64 entry_count = 3;
   */
  entryCount = protoInt64.zero;

  /**
   * @generated from field: int64 size_bytes = 4;
   */
  sizeBytes = protoInt64.zero;

  constructor(data?: PartialMessage<IndexInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.IndexInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "entry_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexInfo {
    return new IndexInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexInfo {
    return new IndexInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexInfo {
    return new IndexInfo().fromJsonString(jsonString, options);
  }

  static equals(a: IndexInfo | PlainMessage<IndexInfo> | undefined, b: IndexInfo | PlainMessage<IndexInfo> | undefined): boolean {
    return proto3.util.equals(IndexInfo, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.AnalyzeChunkRequest
 */
export class AnalyzeChunkRequest extends Message<AnalyzeChunkRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  /**
   * If empty, analyze all chunks
   *
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<AnalyzeChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.AnalyzeChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeChunkRequest | PlainMessage<AnalyzeChunkRequest> | undefined, b: AnalyzeChunkRequest | PlainMessage<AnalyzeChunkRequest> | undefined): boolean {
    return proto3.util.equals(AnalyzeChunkRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.AnalyzeChunkResponse
 */
export class AnalyzeChunkResponse extends Message<AnalyzeChunkResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkAnalysis analyses = 1;
   */
  analyses: ChunkAnalysis[] = [];

  constructor(data?: PartialMessage<AnalyzeChunkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.AnalyzeChunkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "analyses", kind: "message", T: ChunkAnalysis, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeChunkResponse | PlainMessage<AnalyzeChunkResponse> | undefined, b: AnalyzeChunkResponse | PlainMessage<AnalyzeChunkResponse> | undefined): boolean {
    return proto3.util.equals(AnalyzeChunkResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkAnalysis
 */
export class ChunkAnalysis extends Message<ChunkAnalysis> {
  /**
   * @generated from field: string chunk_id = 1;
   */
  chunkId = "";

  /**
   * @generated from field: bool sealed = 2;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 3;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: repeated gastrolog.v1.IndexAnalysis indexes = 4;
   */
  indexes: IndexAnalysis[] = [];

  constructor(data?: PartialMessage<ChunkAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "indexes", kind: "message", T: IndexAnalysis, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkAnalysis | PlainMessage<ChunkAnalysis> | undefined, b: ChunkAnalysis | PlainMessage<ChunkAnalysis> | undefined): boolean {
    return proto3.util.equals(ChunkAnalysis, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.IndexAnalysis
 */
export class IndexAnalysis extends Message<IndexAnalysis> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: bool complete = 2;
   */
  complete = false;

  /**
   * "ok", "missing", "incomplete", "capped"
   *
   * @generated from field: string status = 3;
   */
  status = "";

  /**
   * @generated from field: int64 entry_count = 4;
   */
  entryCount = protoInt64.zero;

  /**
   * 0.0 to 1.0
   *
   * @generated from field: double coverage = 5;
   */
  coverage = 0;

  /**
   * @generated from field: map<string, string> details = 6;
   */
  details: { [key: string]: string } = {};

  constructor(data?: PartialMessage<IndexAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.IndexAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "complete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "entry_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "coverage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "details", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: IndexAnalysis | PlainMessage<IndexAnalysis> | undefined, b: IndexAnalysis | PlainMessage<IndexAnalysis> | undefined): boolean {
    return proto3.util.equals(IndexAnalysis, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStatsRequest
 */
export class GetStatsRequest extends Message<GetStatsRequest> {
  /**
   * If empty, aggregate across all vaults
   *
   * @generated from field: string vault = 1;
   */
  vault = "";

  constructor(data?: PartialMessage<GetStatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatsRequest | PlainMessage<GetStatsRequest> | undefined, b: GetStatsRequest | PlainMessage<GetStatsRequest> | undefined): boolean {
    return proto3.util.equals(GetStatsRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStatsResponse
 */
export class GetStatsResponse extends Message<GetStatsResponse> {
  /**
   * @generated from field: int64 total_vaults = 1;
   */
  totalVaults = protoInt64.zero;

  /**
   * @generated from field: int64 total_chunks = 2;
   */
  totalChunks = protoInt64.zero;

  /**
   * @generated from field: int64 sealed_chunks = 3;
   */
  sealedChunks = protoInt64.zero;

  /**
   * @generated from field: int64 total_records = 4;
   */
  totalRecords = protoInt64.zero;

  /**
   * @generated from field: int64 total_bytes = 5;
   */
  totalBytes = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp oldest_record = 6;
   */
  oldestRecord?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp newest_record = 7;
   */
  newestRecord?: Timestamp;

  /**
   * @generated from field: repeated gastrolog.v1.VaultStats vault_stats = 8;
   */
  vaultStats: VaultStats[] = [];

  /**
   * CPU usage as percentage (0-100+)
   *
   * @generated from field: double process_cpu_percent = 9;
   */
  processCpuPercent = 0;

  /**
   * Summary: HeapInuse + StackInuse
   *
   * @generated from field: int64 process_memory_bytes = 10;
   */
  processMemoryBytes = protoInt64.zero;

  /**
   * @generated from field: gastrolog.v1.ProcessMemoryStats process_memory_stats = 11;
   */
  processMemoryStats?: ProcessMemoryStats;

  constructor(data?: PartialMessage<GetStatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_vaults", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "total_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "sealed_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "total_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "total_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "oldest_record", kind: "message", T: Timestamp },
    { no: 7, name: "newest_record", kind: "message", T: Timestamp },
    { no: 8, name: "vault_stats", kind: "message", T: VaultStats, repeated: true },
    { no: 9, name: "process_cpu_percent", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 10, name: "process_memory_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "process_memory_stats", kind: "message", T: ProcessMemoryStats },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatsResponse | PlainMessage<GetStatsResponse> | undefined, b: GetStatsResponse | PlainMessage<GetStatsResponse> | undefined): boolean {
    return proto3.util.equals(GetStatsResponse, a, b);
  }
}

/**
 * ProcessMemoryStats provides detailed memory breakdown from the Go runtime.
 *
 * @generated from message gastrolog.v1.ProcessMemoryStats
 */
export class ProcessMemoryStats extends Message<ProcessMemoryStats> {
  /**
   * Peak RSS from OS (getrusage Maxrss)
   *
   * @generated from field: int64 rss_bytes = 1;
   */
  rssBytes = protoInt64.zero;

  /**
   * Live heap object bytes
   *
   * @generated from field: int64 heap_alloc_bytes = 2;
   */
  heapAllocBytes = protoInt64.zero;

  /**
   * In-use heap span bytes
   *
   * @generated from field: int64 heap_inuse_bytes = 3;
   */
  heapInuseBytes = protoInt64.zero;

  /**
   * Idle (unused) heap span bytes
   *
   * @generated from field: int64 heap_idle_bytes = 4;
   */
  heapIdleBytes = protoInt64.zero;

  /**
   * Heap bytes released to OS
   *
   * @generated from field: int64 heap_released_bytes = 5;
   */
  heapReleasedBytes = protoInt64.zero;

  /**
   * Stack span bytes
   *
   * @generated from field: int64 stack_inuse_bytes = 6;
   */
  stackInuseBytes = protoInt64.zero;

  /**
   * Total virtual memory from OS
   *
   * @generated from field: int64 sys_bytes = 7;
   */
  sysBytes = protoInt64.zero;

  /**
   * Number of live heap objects
   *
   * @generated from field: uint64 heap_objects = 8;
   */
  heapObjects = protoInt64.zero;

  /**
   * Completed GC cycles
   *
   * @generated from field: uint32 num_gc = 9;
   */
  numGc = 0;

  constructor(data?: PartialMessage<ProcessMemoryStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ProcessMemoryStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rss_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "heap_alloc_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "heap_inuse_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "heap_idle_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "heap_released_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "stack_inuse_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "sys_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "heap_objects", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "num_gc", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessMemoryStats {
    return new ProcessMemoryStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessMemoryStats {
    return new ProcessMemoryStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessMemoryStats {
    return new ProcessMemoryStats().fromJsonString(jsonString, options);
  }

  static equals(a: ProcessMemoryStats | PlainMessage<ProcessMemoryStats> | undefined, b: ProcessMemoryStats | PlainMessage<ProcessMemoryStats> | undefined): boolean {
    return proto3.util.equals(ProcessMemoryStats, a, b);
  }
}

/**
 * VaultStats provides per-vault statistics.
 *
 * @generated from message gastrolog.v1.VaultStats
 */
export class VaultStats extends Message<VaultStats> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: int64 chunk_count = 3;
   */
  chunkCount = protoInt64.zero;

  /**
   * @generated from field: int64 sealed_chunks = 4;
   */
  sealedChunks = protoInt64.zero;

  /**
   * @generated from field: int64 active_chunks = 5;
   */
  activeChunks = protoInt64.zero;

  /**
   * @generated from field: int64 record_count = 6;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: int64 data_bytes = 7;
   */
  dataBytes = protoInt64.zero;

  /**
   * @generated from field: int64 index_bytes = 8;
   */
  indexBytes = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp oldest_record = 9;
   */
  oldestRecord?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp newest_record = 10;
   */
  newestRecord?: Timestamp;

  /**
   * @generated from field: bool enabled = 11;
   */
  enabled = false;

  /**
   * @generated from field: string name = 12;
   */
  name = "";

  constructor(data?: PartialMessage<VaultStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.VaultStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chunk_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "sealed_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "active_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "data_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "index_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "oldest_record", kind: "message", T: Timestamp },
    { no: 10, name: "newest_record", kind: "message", T: Timestamp },
    { no: 11, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultStats {
    return new VaultStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultStats {
    return new VaultStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultStats {
    return new VaultStats().fromJsonString(jsonString, options);
  }

  static equals(a: VaultStats | PlainMessage<VaultStats> | undefined, b: VaultStats | PlainMessage<VaultStats> | undefined): boolean {
    return proto3.util.equals(VaultStats, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ReindexVaultRequest
 */
export class ReindexVaultRequest extends Message<ReindexVaultRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  constructor(data?: PartialMessage<ReindexVaultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ReindexVaultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReindexVaultRequest {
    return new ReindexVaultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReindexVaultRequest {
    return new ReindexVaultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReindexVaultRequest {
    return new ReindexVaultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReindexVaultRequest | PlainMessage<ReindexVaultRequest> | undefined, b: ReindexVaultRequest | PlainMessage<ReindexVaultRequest> | undefined): boolean {
    return proto3.util.equals(ReindexVaultRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ReindexVaultResponse
 */
export class ReindexVaultResponse extends Message<ReindexVaultResponse> {
  /**
   * @generated from field: string job_id = 4;
   */
  jobId = "";

  constructor(data?: PartialMessage<ReindexVaultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ReindexVaultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReindexVaultResponse {
    return new ReindexVaultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReindexVaultResponse {
    return new ReindexVaultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReindexVaultResponse {
    return new ReindexVaultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReindexVaultResponse | PlainMessage<ReindexVaultResponse> | undefined, b: ReindexVaultResponse | PlainMessage<ReindexVaultResponse> | undefined): boolean {
    return proto3.util.equals(ReindexVaultResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ValidateVaultRequest
 */
export class ValidateVaultRequest extends Message<ValidateVaultRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  constructor(data?: PartialMessage<ValidateVaultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ValidateVaultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateVaultRequest {
    return new ValidateVaultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateVaultRequest {
    return new ValidateVaultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateVaultRequest {
    return new ValidateVaultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ValidateVaultRequest | PlainMessage<ValidateVaultRequest> | undefined, b: ValidateVaultRequest | PlainMessage<ValidateVaultRequest> | undefined): boolean {
    return proto3.util.equals(ValidateVaultRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ValidateVaultResponse
 */
export class ValidateVaultResponse extends Message<ValidateVaultResponse> {
  /**
   * @generated from field: bool valid = 1;
   */
  valid = false;

  /**
   * @generated from field: repeated gastrolog.v1.ChunkValidation chunks = 2;
   */
  chunks: ChunkValidation[] = [];

  constructor(data?: PartialMessage<ValidateVaultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ValidateVaultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "chunks", kind: "message", T: ChunkValidation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateVaultResponse {
    return new ValidateVaultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateVaultResponse {
    return new ValidateVaultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateVaultResponse {
    return new ValidateVaultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ValidateVaultResponse | PlainMessage<ValidateVaultResponse> | undefined, b: ValidateVaultResponse | PlainMessage<ValidateVaultResponse> | undefined): boolean {
    return proto3.util.equals(ValidateVaultResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkValidation
 */
export class ChunkValidation extends Message<ChunkValidation> {
  /**
   * @generated from field: string chunk_id = 1;
   */
  chunkId = "";

  /**
   * @generated from field: bool valid = 2;
   */
  valid = false;

  /**
   * @generated from field: repeated string issues = 3;
   */
  issues: string[] = [];

  constructor(data?: PartialMessage<ChunkValidation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkValidation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "issues", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkValidation {
    return new ChunkValidation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkValidation {
    return new ChunkValidation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkValidation {
    return new ChunkValidation().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkValidation | PlainMessage<ChunkValidation> | undefined, b: ChunkValidation | PlainMessage<ChunkValidation> | undefined): boolean {
    return proto3.util.equals(ChunkValidation, a, b);
  }
}

/**
 * MigrateVault moves a vault to a new name, type, and/or location.
 * Three-phase: create destination, freeze source, async merge+delete.
 *
 * @generated from message gastrolog.v1.MigrateVaultRequest
 */
export class MigrateVaultRequest extends Message<MigrateVaultRequest> {
  /**
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * @generated from field: string destination = 2;
   */
  destination = "";

  /**
   * Optional: if empty, uses the same type as the source vault.
   *
   * @generated from field: string destination_type = 3;
   */
  destinationType = "";

  /**
   * @generated from field: map<string, string> destination_params = 4;
   */
  destinationParams: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MigrateVaultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MigrateVaultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "destination_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "destination_params", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MigrateVaultRequest {
    return new MigrateVaultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MigrateVaultRequest {
    return new MigrateVaultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MigrateVaultRequest {
    return new MigrateVaultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MigrateVaultRequest | PlainMessage<MigrateVaultRequest> | undefined, b: MigrateVaultRequest | PlainMessage<MigrateVaultRequest> | undefined): boolean {
    return proto3.util.equals(MigrateVaultRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.MigrateVaultResponse
 */
export class MigrateVaultResponse extends Message<MigrateVaultResponse> {
  /**
   * @generated from field: string job_id = 3;
   */
  jobId = "";

  constructor(data?: PartialMessage<MigrateVaultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MigrateVaultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MigrateVaultResponse {
    return new MigrateVaultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MigrateVaultResponse {
    return new MigrateVaultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MigrateVaultResponse {
    return new MigrateVaultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MigrateVaultResponse | PlainMessage<MigrateVaultResponse> | undefined, b: MigrateVaultResponse | PlainMessage<MigrateVaultResponse> | undefined): boolean {
    return proto3.util.equals(MigrateVaultResponse, a, b);
  }
}

/**
 * ExportVault streams all records from a vault.
 *
 * @generated from message gastrolog.v1.ExportVaultRequest
 */
export class ExportVaultRequest extends Message<ExportVaultRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  constructor(data?: PartialMessage<ExportVaultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExportVaultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportVaultRequest {
    return new ExportVaultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportVaultRequest {
    return new ExportVaultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportVaultRequest {
    return new ExportVaultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExportVaultRequest | PlainMessage<ExportVaultRequest> | undefined, b: ExportVaultRequest | PlainMessage<ExportVaultRequest> | undefined): boolean {
    return proto3.util.equals(ExportVaultRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ExportVaultResponse
 */
export class ExportVaultResponse extends Message<ExportVaultResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ExportRecord records = 1;
   */
  records: ExportRecord[] = [];

  /**
   * @generated from field: bool has_more = 2;
   */
  hasMore = false;

  constructor(data?: PartialMessage<ExportVaultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExportVaultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records", kind: "message", T: ExportRecord, repeated: true },
    { no: 2, name: "has_more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportVaultResponse {
    return new ExportVaultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportVaultResponse {
    return new ExportVaultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportVaultResponse {
    return new ExportVaultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExportVaultResponse | PlainMessage<ExportVaultResponse> | undefined, b: ExportVaultResponse | PlainMessage<ExportVaultResponse> | undefined): boolean {
    return proto3.util.equals(ExportVaultResponse, a, b);
  }
}

/**
 * ExportRecord is a portable record representation for export/import and
 * cross-node search results. The ref fields are optional  only populated
 * when the record originates from a search (not import/export).
 *
 * @generated from message gastrolog.v1.ExportRecord
 */
export class ExportRecord extends Message<ExportRecord> {
  /**
   * @generated from field: google.protobuf.Timestamp source_ts = 1;
   */
  sourceTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp ingest_ts = 2;
   */
  ingestTs?: Timestamp;

  /**
   * @generated from field: map<string, string> attrs = 3;
   */
  attrs: { [key: string]: string } = {};

  /**
   * @generated from field: bytes raw = 4;
   */
  raw = new Uint8Array(0);

  /**
   * Record reference (populated by ForwardSearch, empty for import/export).
   *
   * @generated from field: string vault_id = 5;
   */
  vaultId = "";

  /**
   * @generated from field: string chunk_id = 6;
   */
  chunkId = "";

  /**
   * @generated from field: uint64 pos = 7;
   */
  pos = protoInt64.zero;

  constructor(data?: PartialMessage<ExportRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExportRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_ts", kind: "message", T: Timestamp },
    { no: 2, name: "ingest_ts", kind: "message", T: Timestamp },
    { no: 3, name: "attrs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "raw", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "vault_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "pos", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportRecord {
    return new ExportRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportRecord {
    return new ExportRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportRecord {
    return new ExportRecord().fromJsonString(jsonString, options);
  }

  static equals(a: ExportRecord | PlainMessage<ExportRecord> | undefined, b: ExportRecord | PlainMessage<ExportRecord> | undefined): boolean {
    return proto3.util.equals(ExportRecord, a, b);
  }
}

/**
 * ImportRecords appends a batch of records to a vault.
 *
 * @generated from message gastrolog.v1.ImportRecordsRequest
 */
export class ImportRecordsRequest extends Message<ImportRecordsRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  /**
   * @generated from field: repeated gastrolog.v1.ExportRecord records = 2;
   */
  records: ExportRecord[] = [];

  constructor(data?: PartialMessage<ImportRecordsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ImportRecordsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "records", kind: "message", T: ExportRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportRecordsRequest {
    return new ImportRecordsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportRecordsRequest {
    return new ImportRecordsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportRecordsRequest {
    return new ImportRecordsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ImportRecordsRequest | PlainMessage<ImportRecordsRequest> | undefined, b: ImportRecordsRequest | PlainMessage<ImportRecordsRequest> | undefined): boolean {
    return proto3.util.equals(ImportRecordsRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ImportRecordsResponse
 */
export class ImportRecordsResponse extends Message<ImportRecordsResponse> {
  /**
   * @generated from field: int64 records_imported = 1;
   */
  recordsImported = protoInt64.zero;

  constructor(data?: PartialMessage<ImportRecordsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ImportRecordsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records_imported", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportRecordsResponse {
    return new ImportRecordsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportRecordsResponse {
    return new ImportRecordsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportRecordsResponse {
    return new ImportRecordsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImportRecordsResponse | PlainMessage<ImportRecordsResponse> | undefined, b: ImportRecordsResponse | PlainMessage<ImportRecordsResponse> | undefined): boolean {
    return proto3.util.equals(ImportRecordsResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.MergeVaultsRequest
 */
export class MergeVaultsRequest extends Message<MergeVaultsRequest> {
  /**
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * @generated from field: string destination = 2;
   */
  destination = "";

  constructor(data?: PartialMessage<MergeVaultsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MergeVaultsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MergeVaultsRequest {
    return new MergeVaultsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MergeVaultsRequest {
    return new MergeVaultsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MergeVaultsRequest {
    return new MergeVaultsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MergeVaultsRequest | PlainMessage<MergeVaultsRequest> | undefined, b: MergeVaultsRequest | PlainMessage<MergeVaultsRequest> | undefined): boolean {
    return proto3.util.equals(MergeVaultsRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.MergeVaultsResponse
 */
export class MergeVaultsResponse extends Message<MergeVaultsResponse> {
  /**
   * @generated from field: string job_id = 3;
   */
  jobId = "";

  constructor(data?: PartialMessage<MergeVaultsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MergeVaultsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MergeVaultsResponse {
    return new MergeVaultsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MergeVaultsResponse {
    return new MergeVaultsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MergeVaultsResponse {
    return new MergeVaultsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MergeVaultsResponse | PlainMessage<MergeVaultsResponse> | undefined, b: MergeVaultsResponse | PlainMessage<MergeVaultsResponse> | undefined): boolean {
    return proto3.util.equals(MergeVaultsResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.SealVaultRequest
 */
export class SealVaultRequest extends Message<SealVaultRequest> {
  /**
   * @generated from field: string vault = 1;
   */
  vault = "";

  constructor(data?: PartialMessage<SealVaultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.SealVaultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SealVaultRequest {
    return new SealVaultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SealVaultRequest {
    return new SealVaultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SealVaultRequest {
    return new SealVaultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SealVaultRequest | PlainMessage<SealVaultRequest> | undefined, b: SealVaultRequest | PlainMessage<SealVaultRequest> | undefined): boolean {
    return proto3.util.equals(SealVaultRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.SealVaultResponse
 */
export class SealVaultResponse extends Message<SealVaultResponse> {
  constructor(data?: PartialMessage<SealVaultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.SealVaultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SealVaultResponse {
    return new SealVaultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SealVaultResponse {
    return new SealVaultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SealVaultResponse {
    return new SealVaultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SealVaultResponse | PlainMessage<SealVaultResponse> | undefined, b: SealVaultResponse | PlainMessage<SealVaultResponse> | undefined): boolean {
    return proto3.util.equals(SealVaultResponse, a, b);
  }
}

