// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file gastrolog/v1/store.proto (package gastrolog.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message gastrolog.v1.ListStoresRequest
 */
export class ListStoresRequest extends Message<ListStoresRequest> {
  constructor(data?: PartialMessage<ListStoresRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListStoresRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListStoresRequest {
    return new ListStoresRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListStoresRequest {
    return new ListStoresRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListStoresRequest {
    return new ListStoresRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListStoresRequest | PlainMessage<ListStoresRequest> | undefined, b: ListStoresRequest | PlainMessage<ListStoresRequest> | undefined): boolean {
    return proto3.util.equals(ListStoresRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListStoresResponse
 */
export class ListStoresResponse extends Message<ListStoresResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.StoreInfo stores = 1;
   */
  stores: StoreInfo[] = [];

  constructor(data?: PartialMessage<ListStoresResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListStoresResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stores", kind: "message", T: StoreInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListStoresResponse {
    return new ListStoresResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListStoresResponse {
    return new ListStoresResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListStoresResponse {
    return new ListStoresResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListStoresResponse | PlainMessage<ListStoresResponse> | undefined, b: ListStoresResponse | PlainMessage<ListStoresResponse> | undefined): boolean {
    return proto3.util.equals(ListStoresResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.StoreInfo
 */
export class StoreInfo extends Message<StoreInfo> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: string filter = 3;
   */
  filter = "";

  /**
   * @generated from field: int64 chunk_count = 4;
   */
  chunkCount = protoInt64.zero;

  /**
   * @generated from field: int64 record_count = 5;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: bool enabled = 6;
   */
  enabled = false;

  /**
   * @generated from field: string name = 7;
   */
  name = "";

  constructor(data?: PartialMessage<StoreInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.StoreInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "chunk_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreInfo {
    return new StoreInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreInfo {
    return new StoreInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreInfo {
    return new StoreInfo().fromJsonString(jsonString, options);
  }

  static equals(a: StoreInfo | PlainMessage<StoreInfo> | undefined, b: StoreInfo | PlainMessage<StoreInfo> | undefined): boolean {
    return proto3.util.equals(StoreInfo, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStoreRequest
 */
export class GetStoreRequest extends Message<GetStoreRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStoreRequest {
    return new GetStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStoreRequest {
    return new GetStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStoreRequest {
    return new GetStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetStoreRequest | PlainMessage<GetStoreRequest> | undefined, b: GetStoreRequest | PlainMessage<GetStoreRequest> | undefined): boolean {
    return proto3.util.equals(GetStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStoreResponse
 */
export class GetStoreResponse extends Message<GetStoreResponse> {
  /**
   * @generated from field: gastrolog.v1.StoreInfo store = 1;
   */
  store?: StoreInfo;

  constructor(data?: PartialMessage<GetStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "message", T: StoreInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStoreResponse {
    return new GetStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStoreResponse {
    return new GetStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStoreResponse {
    return new GetStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStoreResponse | PlainMessage<GetStoreResponse> | undefined, b: GetStoreResponse | PlainMessage<GetStoreResponse> | undefined): boolean {
    return proto3.util.equals(GetStoreResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListChunksRequest
 */
export class ListChunksRequest extends Message<ListChunksRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<ListChunksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListChunksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListChunksRequest | PlainMessage<ListChunksRequest> | undefined, b: ListChunksRequest | PlainMessage<ListChunksRequest> | undefined): boolean {
    return proto3.util.equals(ListChunksRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListChunksResponse
 */
export class ListChunksResponse extends Message<ListChunksResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkMeta chunks = 1;
   */
  chunks: ChunkMeta[] = [];

  constructor(data?: PartialMessage<ListChunksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListChunksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks", kind: "message", T: ChunkMeta, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListChunksResponse | PlainMessage<ListChunksResponse> | undefined, b: ListChunksResponse | PlainMessage<ListChunksResponse> | undefined): boolean {
    return proto3.util.equals(ListChunksResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkMeta
 */
export class ChunkMeta extends Message<ChunkMeta> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: google.protobuf.Timestamp start_ts = 2;
   */
  startTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_ts = 3;
   */
  endTs?: Timestamp;

  /**
   * @generated from field: bool sealed = 4;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 5;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: int64 bytes = 6;
   */
  bytes = protoInt64.zero;

  constructor(data?: PartialMessage<ChunkMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_ts", kind: "message", T: Timestamp },
    { no: 3, name: "end_ts", kind: "message", T: Timestamp },
    { no: 4, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkMeta {
    return new ChunkMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkMeta {
    return new ChunkMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkMeta {
    return new ChunkMeta().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkMeta | PlainMessage<ChunkMeta> | undefined, b: ChunkMeta | PlainMessage<ChunkMeta> | undefined): boolean {
    return proto3.util.equals(ChunkMeta, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetChunkRequest
 */
export class GetChunkRequest extends Message<GetChunkRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<GetChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChunkRequest | PlainMessage<GetChunkRequest> | undefined, b: GetChunkRequest | PlainMessage<GetChunkRequest> | undefined): boolean {
    return proto3.util.equals(GetChunkRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetChunkResponse
 */
export class GetChunkResponse extends Message<GetChunkResponse> {
  /**
   * @generated from field: gastrolog.v1.ChunkMeta chunk = 1;
   */
  chunk?: ChunkMeta;

  constructor(data?: PartialMessage<GetChunkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetChunkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk", kind: "message", T: ChunkMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChunkResponse | PlainMessage<GetChunkResponse> | undefined, b: GetChunkResponse | PlainMessage<GetChunkResponse> | undefined): boolean {
    return proto3.util.equals(GetChunkResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetIndexesRequest
 */
export class GetIndexesRequest extends Message<GetIndexesRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<GetIndexesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetIndexesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIndexesRequest | PlainMessage<GetIndexesRequest> | undefined, b: GetIndexesRequest | PlainMessage<GetIndexesRequest> | undefined): boolean {
    return proto3.util.equals(GetIndexesRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetIndexesResponse
 */
export class GetIndexesResponse extends Message<GetIndexesResponse> {
  /**
   * @generated from field: bool sealed = 1;
   */
  sealed = false;

  /**
   * @generated from field: repeated gastrolog.v1.IndexInfo indexes = 2;
   */
  indexes: IndexInfo[] = [];

  constructor(data?: PartialMessage<GetIndexesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetIndexesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "indexes", kind: "message", T: IndexInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIndexesResponse | PlainMessage<GetIndexesResponse> | undefined, b: GetIndexesResponse | PlainMessage<GetIndexesResponse> | undefined): boolean {
    return proto3.util.equals(GetIndexesResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.IndexInfo
 */
export class IndexInfo extends Message<IndexInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: bool exists = 2;
   */
  exists = false;

  /**
   * @generated from field: int64 entry_count = 3;
   */
  entryCount = protoInt64.zero;

  /**
   * @generated from field: int64 size_bytes = 4;
   */
  sizeBytes = protoInt64.zero;

  constructor(data?: PartialMessage<IndexInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.IndexInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "entry_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexInfo {
    return new IndexInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexInfo {
    return new IndexInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexInfo {
    return new IndexInfo().fromJsonString(jsonString, options);
  }

  static equals(a: IndexInfo | PlainMessage<IndexInfo> | undefined, b: IndexInfo | PlainMessage<IndexInfo> | undefined): boolean {
    return proto3.util.equals(IndexInfo, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.AnalyzeChunkRequest
 */
export class AnalyzeChunkRequest extends Message<AnalyzeChunkRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * If empty, analyze all chunks
   *
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<AnalyzeChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.AnalyzeChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeChunkRequest | PlainMessage<AnalyzeChunkRequest> | undefined, b: AnalyzeChunkRequest | PlainMessage<AnalyzeChunkRequest> | undefined): boolean {
    return proto3.util.equals(AnalyzeChunkRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.AnalyzeChunkResponse
 */
export class AnalyzeChunkResponse extends Message<AnalyzeChunkResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkAnalysis analyses = 1;
   */
  analyses: ChunkAnalysis[] = [];

  constructor(data?: PartialMessage<AnalyzeChunkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.AnalyzeChunkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "analyses", kind: "message", T: ChunkAnalysis, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeChunkResponse | PlainMessage<AnalyzeChunkResponse> | undefined, b: AnalyzeChunkResponse | PlainMessage<AnalyzeChunkResponse> | undefined): boolean {
    return proto3.util.equals(AnalyzeChunkResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkAnalysis
 */
export class ChunkAnalysis extends Message<ChunkAnalysis> {
  /**
   * @generated from field: string chunk_id = 1;
   */
  chunkId = "";

  /**
   * @generated from field: bool sealed = 2;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 3;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: repeated gastrolog.v1.IndexAnalysis indexes = 4;
   */
  indexes: IndexAnalysis[] = [];

  constructor(data?: PartialMessage<ChunkAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "indexes", kind: "message", T: IndexAnalysis, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkAnalysis | PlainMessage<ChunkAnalysis> | undefined, b: ChunkAnalysis | PlainMessage<ChunkAnalysis> | undefined): boolean {
    return proto3.util.equals(ChunkAnalysis, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.IndexAnalysis
 */
export class IndexAnalysis extends Message<IndexAnalysis> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: bool complete = 2;
   */
  complete = false;

  /**
   * "ok", "missing", "incomplete", "capped"
   *
   * @generated from field: string status = 3;
   */
  status = "";

  /**
   * @generated from field: int64 entry_count = 4;
   */
  entryCount = protoInt64.zero;

  /**
   * 0.0 to 1.0
   *
   * @generated from field: double coverage = 5;
   */
  coverage = 0;

  /**
   * @generated from field: map<string, string> details = 6;
   */
  details: { [key: string]: string } = {};

  constructor(data?: PartialMessage<IndexAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.IndexAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "complete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "entry_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "coverage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "details", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: IndexAnalysis | PlainMessage<IndexAnalysis> | undefined, b: IndexAnalysis | PlainMessage<IndexAnalysis> | undefined): boolean {
    return proto3.util.equals(IndexAnalysis, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStatsRequest
 */
export class GetStatsRequest extends Message<GetStatsRequest> {
  /**
   * If empty, aggregate across all stores
   *
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<GetStatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatsRequest | PlainMessage<GetStatsRequest> | undefined, b: GetStatsRequest | PlainMessage<GetStatsRequest> | undefined): boolean {
    return proto3.util.equals(GetStatsRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStatsResponse
 */
export class GetStatsResponse extends Message<GetStatsResponse> {
  /**
   * @generated from field: int64 total_stores = 1;
   */
  totalStores = protoInt64.zero;

  /**
   * @generated from field: int64 total_chunks = 2;
   */
  totalChunks = protoInt64.zero;

  /**
   * @generated from field: int64 sealed_chunks = 3;
   */
  sealedChunks = protoInt64.zero;

  /**
   * @generated from field: int64 total_records = 4;
   */
  totalRecords = protoInt64.zero;

  /**
   * @generated from field: int64 total_bytes = 5;
   */
  totalBytes = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp oldest_record = 6;
   */
  oldestRecord?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp newest_record = 7;
   */
  newestRecord?: Timestamp;

  /**
   * @generated from field: repeated gastrolog.v1.StoreStats store_stats = 8;
   */
  storeStats: StoreStats[] = [];

  constructor(data?: PartialMessage<GetStatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_stores", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "total_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "sealed_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "total_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "total_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "oldest_record", kind: "message", T: Timestamp },
    { no: 7, name: "newest_record", kind: "message", T: Timestamp },
    { no: 8, name: "store_stats", kind: "message", T: StoreStats, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatsResponse | PlainMessage<GetStatsResponse> | undefined, b: GetStatsResponse | PlainMessage<GetStatsResponse> | undefined): boolean {
    return proto3.util.equals(GetStatsResponse, a, b);
  }
}

/**
 * StoreStats provides per-store statistics.
 *
 * @generated from message gastrolog.v1.StoreStats
 */
export class StoreStats extends Message<StoreStats> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: int64 chunk_count = 3;
   */
  chunkCount = protoInt64.zero;

  /**
   * @generated from field: int64 sealed_chunks = 4;
   */
  sealedChunks = protoInt64.zero;

  /**
   * @generated from field: int64 active_chunks = 5;
   */
  activeChunks = protoInt64.zero;

  /**
   * @generated from field: int64 record_count = 6;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: int64 data_bytes = 7;
   */
  dataBytes = protoInt64.zero;

  /**
   * @generated from field: int64 index_bytes = 8;
   */
  indexBytes = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp oldest_record = 9;
   */
  oldestRecord?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp newest_record = 10;
   */
  newestRecord?: Timestamp;

  /**
   * @generated from field: bool enabled = 11;
   */
  enabled = false;

  /**
   * @generated from field: string name = 12;
   */
  name = "";

  constructor(data?: PartialMessage<StoreStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.StoreStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chunk_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "sealed_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "active_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "data_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "index_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "oldest_record", kind: "message", T: Timestamp },
    { no: 10, name: "newest_record", kind: "message", T: Timestamp },
    { no: 11, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreStats {
    return new StoreStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreStats {
    return new StoreStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreStats {
    return new StoreStats().fromJsonString(jsonString, options);
  }

  static equals(a: StoreStats | PlainMessage<StoreStats> | undefined, b: StoreStats | PlainMessage<StoreStats> | undefined): boolean {
    return proto3.util.equals(StoreStats, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ReindexStoreRequest
 */
export class ReindexStoreRequest extends Message<ReindexStoreRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<ReindexStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ReindexStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReindexStoreRequest {
    return new ReindexStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReindexStoreRequest {
    return new ReindexStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReindexStoreRequest {
    return new ReindexStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReindexStoreRequest | PlainMessage<ReindexStoreRequest> | undefined, b: ReindexStoreRequest | PlainMessage<ReindexStoreRequest> | undefined): boolean {
    return proto3.util.equals(ReindexStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ReindexStoreResponse
 */
export class ReindexStoreResponse extends Message<ReindexStoreResponse> {
  /**
   * @generated from field: int64 chunks_reindexed = 1;
   */
  chunksReindexed = protoInt64.zero;

  /**
   * @generated from field: int64 errors = 2;
   */
  errors = protoInt64.zero;

  /**
   * @generated from field: repeated string error_details = 3;
   */
  errorDetails: string[] = [];

  constructor(data?: PartialMessage<ReindexStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ReindexStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks_reindexed", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "errors", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "error_details", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReindexStoreResponse {
    return new ReindexStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReindexStoreResponse {
    return new ReindexStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReindexStoreResponse {
    return new ReindexStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReindexStoreResponse | PlainMessage<ReindexStoreResponse> | undefined, b: ReindexStoreResponse | PlainMessage<ReindexStoreResponse> | undefined): boolean {
    return proto3.util.equals(ReindexStoreResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ValidateStoreRequest
 */
export class ValidateStoreRequest extends Message<ValidateStoreRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<ValidateStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ValidateStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateStoreRequest {
    return new ValidateStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateStoreRequest {
    return new ValidateStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateStoreRequest {
    return new ValidateStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ValidateStoreRequest | PlainMessage<ValidateStoreRequest> | undefined, b: ValidateStoreRequest | PlainMessage<ValidateStoreRequest> | undefined): boolean {
    return proto3.util.equals(ValidateStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ValidateStoreResponse
 */
export class ValidateStoreResponse extends Message<ValidateStoreResponse> {
  /**
   * @generated from field: bool valid = 1;
   */
  valid = false;

  /**
   * @generated from field: repeated gastrolog.v1.ChunkValidation chunks = 2;
   */
  chunks: ChunkValidation[] = [];

  constructor(data?: PartialMessage<ValidateStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ValidateStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "chunks", kind: "message", T: ChunkValidation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateStoreResponse {
    return new ValidateStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateStoreResponse {
    return new ValidateStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateStoreResponse {
    return new ValidateStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ValidateStoreResponse | PlainMessage<ValidateStoreResponse> | undefined, b: ValidateStoreResponse | PlainMessage<ValidateStoreResponse> | undefined): boolean {
    return proto3.util.equals(ValidateStoreResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkValidation
 */
export class ChunkValidation extends Message<ChunkValidation> {
  /**
   * @generated from field: string chunk_id = 1;
   */
  chunkId = "";

  /**
   * @generated from field: bool valid = 2;
   */
  valid = false;

  /**
   * @generated from field: repeated string issues = 3;
   */
  issues: string[] = [];

  constructor(data?: PartialMessage<ChunkValidation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkValidation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "issues", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkValidation {
    return new ChunkValidation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkValidation {
    return new ChunkValidation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkValidation {
    return new ChunkValidation().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkValidation | PlainMessage<ChunkValidation> | undefined, b: ChunkValidation | PlainMessage<ChunkValidation> | undefined): boolean {
    return proto3.util.equals(ChunkValidation, a, b);
  }
}

/**
 * CloneStore copies all records from source to a new store with the same config.
 *
 * @generated from message gastrolog.v1.CloneStoreRequest
 */
export class CloneStoreRequest extends Message<CloneStoreRequest> {
  /**
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * @generated from field: string destination = 2;
   */
  destination = "";

  /**
   * Optional overrides for destination store params (e.g. dir for file stores).
   * Merged on top of source params.
   *
   * @generated from field: map<string, string> destination_params = 3;
   */
  destinationParams: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CloneStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.CloneStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "destination_params", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloneStoreRequest {
    return new CloneStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloneStoreRequest {
    return new CloneStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloneStoreRequest {
    return new CloneStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CloneStoreRequest | PlainMessage<CloneStoreRequest> | undefined, b: CloneStoreRequest | PlainMessage<CloneStoreRequest> | undefined): boolean {
    return proto3.util.equals(CloneStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.CloneStoreResponse
 */
export class CloneStoreResponse extends Message<CloneStoreResponse> {
  /**
   * @generated from field: int64 records_copied = 1;
   */
  recordsCopied = protoInt64.zero;

  /**
   * @generated from field: int64 chunks_created = 2;
   */
  chunksCreated = protoInt64.zero;

  constructor(data?: PartialMessage<CloneStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.CloneStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records_copied", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "chunks_created", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloneStoreResponse {
    return new CloneStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloneStoreResponse {
    return new CloneStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloneStoreResponse {
    return new CloneStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CloneStoreResponse | PlainMessage<CloneStoreResponse> | undefined, b: CloneStoreResponse | PlainMessage<CloneStoreResponse> | undefined): boolean {
    return proto3.util.equals(CloneStoreResponse, a, b);
  }
}

/**
 * MigrateStore copies records to a new store of a different type, then deletes the source.
 *
 * @generated from message gastrolog.v1.MigrateStoreRequest
 */
export class MigrateStoreRequest extends Message<MigrateStoreRequest> {
  /**
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * @generated from field: string destination = 2;
   */
  destination = "";

  /**
   * @generated from field: string destination_type = 3;
   */
  destinationType = "";

  /**
   * @generated from field: map<string, string> destination_params = 4;
   */
  destinationParams: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MigrateStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MigrateStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "destination_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "destination_params", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MigrateStoreRequest {
    return new MigrateStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MigrateStoreRequest {
    return new MigrateStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MigrateStoreRequest {
    return new MigrateStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MigrateStoreRequest | PlainMessage<MigrateStoreRequest> | undefined, b: MigrateStoreRequest | PlainMessage<MigrateStoreRequest> | undefined): boolean {
    return proto3.util.equals(MigrateStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.MigrateStoreResponse
 */
export class MigrateStoreResponse extends Message<MigrateStoreResponse> {
  /**
   * @generated from field: int64 records_migrated = 1;
   */
  recordsMigrated = protoInt64.zero;

  /**
   * @generated from field: int64 chunks_created = 2;
   */
  chunksCreated = protoInt64.zero;

  constructor(data?: PartialMessage<MigrateStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MigrateStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records_migrated", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "chunks_created", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MigrateStoreResponse {
    return new MigrateStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MigrateStoreResponse {
    return new MigrateStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MigrateStoreResponse {
    return new MigrateStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MigrateStoreResponse | PlainMessage<MigrateStoreResponse> | undefined, b: MigrateStoreResponse | PlainMessage<MigrateStoreResponse> | undefined): boolean {
    return proto3.util.equals(MigrateStoreResponse, a, b);
  }
}

/**
 * ExportStore streams all records from a store.
 *
 * @generated from message gastrolog.v1.ExportStoreRequest
 */
export class ExportStoreRequest extends Message<ExportStoreRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<ExportStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExportStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportStoreRequest {
    return new ExportStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportStoreRequest {
    return new ExportStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportStoreRequest {
    return new ExportStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExportStoreRequest | PlainMessage<ExportStoreRequest> | undefined, b: ExportStoreRequest | PlainMessage<ExportStoreRequest> | undefined): boolean {
    return proto3.util.equals(ExportStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ExportStoreResponse
 */
export class ExportStoreResponse extends Message<ExportStoreResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ExportRecord records = 1;
   */
  records: ExportRecord[] = [];

  /**
   * @generated from field: bool has_more = 2;
   */
  hasMore = false;

  constructor(data?: PartialMessage<ExportStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExportStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records", kind: "message", T: ExportRecord, repeated: true },
    { no: 2, name: "has_more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportStoreResponse {
    return new ExportStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportStoreResponse {
    return new ExportStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportStoreResponse {
    return new ExportStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExportStoreResponse | PlainMessage<ExportStoreResponse> | undefined, b: ExportStoreResponse | PlainMessage<ExportStoreResponse> | undefined): boolean {
    return proto3.util.equals(ExportStoreResponse, a, b);
  }
}

/**
 * ExportRecord is a portable record representation for export/import.
 *
 * @generated from message gastrolog.v1.ExportRecord
 */
export class ExportRecord extends Message<ExportRecord> {
  /**
   * @generated from field: google.protobuf.Timestamp source_ts = 1;
   */
  sourceTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp ingest_ts = 2;
   */
  ingestTs?: Timestamp;

  /**
   * @generated from field: map<string, string> attrs = 3;
   */
  attrs: { [key: string]: string } = {};

  /**
   * @generated from field: bytes raw = 4;
   */
  raw = new Uint8Array(0);

  constructor(data?: PartialMessage<ExportRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExportRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_ts", kind: "message", T: Timestamp },
    { no: 2, name: "ingest_ts", kind: "message", T: Timestamp },
    { no: 3, name: "attrs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "raw", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportRecord {
    return new ExportRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportRecord {
    return new ExportRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportRecord {
    return new ExportRecord().fromJsonString(jsonString, options);
  }

  static equals(a: ExportRecord | PlainMessage<ExportRecord> | undefined, b: ExportRecord | PlainMessage<ExportRecord> | undefined): boolean {
    return proto3.util.equals(ExportRecord, a, b);
  }
}

/**
 * ImportRecords appends a batch of records to a store.
 *
 * @generated from message gastrolog.v1.ImportRecordsRequest
 */
export class ImportRecordsRequest extends Message<ImportRecordsRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * @generated from field: repeated gastrolog.v1.ExportRecord records = 2;
   */
  records: ExportRecord[] = [];

  constructor(data?: PartialMessage<ImportRecordsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ImportRecordsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "records", kind: "message", T: ExportRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportRecordsRequest {
    return new ImportRecordsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportRecordsRequest {
    return new ImportRecordsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportRecordsRequest {
    return new ImportRecordsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ImportRecordsRequest | PlainMessage<ImportRecordsRequest> | undefined, b: ImportRecordsRequest | PlainMessage<ImportRecordsRequest> | undefined): boolean {
    return proto3.util.equals(ImportRecordsRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ImportRecordsResponse
 */
export class ImportRecordsResponse extends Message<ImportRecordsResponse> {
  /**
   * @generated from field: int64 records_imported = 1;
   */
  recordsImported = protoInt64.zero;

  constructor(data?: PartialMessage<ImportRecordsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ImportRecordsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records_imported", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportRecordsResponse {
    return new ImportRecordsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportRecordsResponse {
    return new ImportRecordsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportRecordsResponse {
    return new ImportRecordsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImportRecordsResponse | PlainMessage<ImportRecordsResponse> | undefined, b: ImportRecordsResponse | PlainMessage<ImportRecordsResponse> | undefined): boolean {
    return proto3.util.equals(ImportRecordsResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.CompactStoreRequest
 */
export class CompactStoreRequest extends Message<CompactStoreRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<CompactStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.CompactStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompactStoreRequest {
    return new CompactStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompactStoreRequest {
    return new CompactStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompactStoreRequest {
    return new CompactStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CompactStoreRequest | PlainMessage<CompactStoreRequest> | undefined, b: CompactStoreRequest | PlainMessage<CompactStoreRequest> | undefined): boolean {
    return proto3.util.equals(CompactStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.CompactStoreResponse
 */
export class CompactStoreResponse extends Message<CompactStoreResponse> {
  /**
   * @generated from field: int64 chunks_removed = 1;
   */
  chunksRemoved = protoInt64.zero;

  /**
   * @generated from field: int64 bytes_reclaimed = 2;
   */
  bytesReclaimed = protoInt64.zero;

  constructor(data?: PartialMessage<CompactStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.CompactStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks_removed", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "bytes_reclaimed", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompactStoreResponse {
    return new CompactStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompactStoreResponse {
    return new CompactStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompactStoreResponse {
    return new CompactStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CompactStoreResponse | PlainMessage<CompactStoreResponse> | undefined, b: CompactStoreResponse | PlainMessage<CompactStoreResponse> | undefined): boolean {
    return proto3.util.equals(CompactStoreResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.MergeStoresRequest
 */
export class MergeStoresRequest extends Message<MergeStoresRequest> {
  /**
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * @generated from field: string destination = 2;
   */
  destination = "";

  constructor(data?: PartialMessage<MergeStoresRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MergeStoresRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MergeStoresRequest {
    return new MergeStoresRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MergeStoresRequest {
    return new MergeStoresRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MergeStoresRequest {
    return new MergeStoresRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MergeStoresRequest | PlainMessage<MergeStoresRequest> | undefined, b: MergeStoresRequest | PlainMessage<MergeStoresRequest> | undefined): boolean {
    return proto3.util.equals(MergeStoresRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.MergeStoresResponse
 */
export class MergeStoresResponse extends Message<MergeStoresResponse> {
  /**
   * @generated from field: int64 records_merged = 1;
   */
  recordsMerged = protoInt64.zero;

  /**
   * @generated from field: int64 chunks_created = 2;
   */
  chunksCreated = protoInt64.zero;

  constructor(data?: PartialMessage<MergeStoresResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.MergeStoresResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records_merged", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "chunks_created", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MergeStoresResponse {
    return new MergeStoresResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MergeStoresResponse {
    return new MergeStoresResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MergeStoresResponse {
    return new MergeStoresResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MergeStoresResponse | PlainMessage<MergeStoresResponse> | undefined, b: MergeStoresResponse | PlainMessage<MergeStoresResponse> | undefined): boolean {
    return proto3.util.equals(MergeStoresResponse, a, b);
  }
}

