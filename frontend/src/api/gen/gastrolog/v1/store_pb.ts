// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file gastrolog/v1/store.proto (package gastrolog.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message gastrolog.v1.ListStoresRequest
 */
export class ListStoresRequest extends Message<ListStoresRequest> {
  constructor(data?: PartialMessage<ListStoresRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListStoresRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListStoresRequest {
    return new ListStoresRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListStoresRequest {
    return new ListStoresRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListStoresRequest {
    return new ListStoresRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListStoresRequest | PlainMessage<ListStoresRequest> | undefined, b: ListStoresRequest | PlainMessage<ListStoresRequest> | undefined): boolean {
    return proto3.util.equals(ListStoresRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListStoresResponse
 */
export class ListStoresResponse extends Message<ListStoresResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.StoreInfo stores = 1;
   */
  stores: StoreInfo[] = [];

  constructor(data?: PartialMessage<ListStoresResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListStoresResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stores", kind: "message", T: StoreInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListStoresResponse {
    return new ListStoresResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListStoresResponse {
    return new ListStoresResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListStoresResponse {
    return new ListStoresResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListStoresResponse | PlainMessage<ListStoresResponse> | undefined, b: ListStoresResponse | PlainMessage<ListStoresResponse> | undefined): boolean {
    return proto3.util.equals(ListStoresResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.StoreInfo
 */
export class StoreInfo extends Message<StoreInfo> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: string filter = 3;
   */
  filter = "";

  /**
   * @generated from field: int64 chunk_count = 4;
   */
  chunkCount = protoInt64.zero;

  /**
   * @generated from field: int64 record_count = 5;
   */
  recordCount = protoInt64.zero;

  constructor(data?: PartialMessage<StoreInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.StoreInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "chunk_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreInfo {
    return new StoreInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreInfo {
    return new StoreInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreInfo {
    return new StoreInfo().fromJsonString(jsonString, options);
  }

  static equals(a: StoreInfo | PlainMessage<StoreInfo> | undefined, b: StoreInfo | PlainMessage<StoreInfo> | undefined): boolean {
    return proto3.util.equals(StoreInfo, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStoreRequest
 */
export class GetStoreRequest extends Message<GetStoreRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetStoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStoreRequest {
    return new GetStoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStoreRequest {
    return new GetStoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStoreRequest {
    return new GetStoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetStoreRequest | PlainMessage<GetStoreRequest> | undefined, b: GetStoreRequest | PlainMessage<GetStoreRequest> | undefined): boolean {
    return proto3.util.equals(GetStoreRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStoreResponse
 */
export class GetStoreResponse extends Message<GetStoreResponse> {
  /**
   * @generated from field: gastrolog.v1.StoreInfo store = 1;
   */
  store?: StoreInfo;

  constructor(data?: PartialMessage<GetStoreResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStoreResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "message", T: StoreInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStoreResponse {
    return new GetStoreResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStoreResponse {
    return new GetStoreResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStoreResponse {
    return new GetStoreResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStoreResponse | PlainMessage<GetStoreResponse> | undefined, b: GetStoreResponse | PlainMessage<GetStoreResponse> | undefined): boolean {
    return proto3.util.equals(GetStoreResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListChunksRequest
 */
export class ListChunksRequest extends Message<ListChunksRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<ListChunksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListChunksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListChunksRequest {
    return new ListChunksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListChunksRequest | PlainMessage<ListChunksRequest> | undefined, b: ListChunksRequest | PlainMessage<ListChunksRequest> | undefined): boolean {
    return proto3.util.equals(ListChunksRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ListChunksResponse
 */
export class ListChunksResponse extends Message<ListChunksResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkMeta chunks = 1;
   */
  chunks: ChunkMeta[] = [];

  constructor(data?: PartialMessage<ListChunksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ListChunksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks", kind: "message", T: ChunkMeta, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListChunksResponse {
    return new ListChunksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListChunksResponse | PlainMessage<ListChunksResponse> | undefined, b: ListChunksResponse | PlainMessage<ListChunksResponse> | undefined): boolean {
    return proto3.util.equals(ListChunksResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkMeta
 */
export class ChunkMeta extends Message<ChunkMeta> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: google.protobuf.Timestamp start_ts = 2;
   */
  startTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_ts = 3;
   */
  endTs?: Timestamp;

  /**
   * @generated from field: bool sealed = 4;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 5;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: int64 bytes = 6;
   */
  bytes = protoInt64.zero;

  constructor(data?: PartialMessage<ChunkMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_ts", kind: "message", T: Timestamp },
    { no: 3, name: "end_ts", kind: "message", T: Timestamp },
    { no: 4, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkMeta {
    return new ChunkMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkMeta {
    return new ChunkMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkMeta {
    return new ChunkMeta().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkMeta | PlainMessage<ChunkMeta> | undefined, b: ChunkMeta | PlainMessage<ChunkMeta> | undefined): boolean {
    return proto3.util.equals(ChunkMeta, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetChunkRequest
 */
export class GetChunkRequest extends Message<GetChunkRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<GetChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChunkRequest {
    return new GetChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChunkRequest | PlainMessage<GetChunkRequest> | undefined, b: GetChunkRequest | PlainMessage<GetChunkRequest> | undefined): boolean {
    return proto3.util.equals(GetChunkRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetChunkResponse
 */
export class GetChunkResponse extends Message<GetChunkResponse> {
  /**
   * @generated from field: gastrolog.v1.ChunkMeta chunk = 1;
   */
  chunk?: ChunkMeta;

  constructor(data?: PartialMessage<GetChunkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetChunkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk", kind: "message", T: ChunkMeta },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChunkResponse {
    return new GetChunkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChunkResponse | PlainMessage<GetChunkResponse> | undefined, b: GetChunkResponse | PlainMessage<GetChunkResponse> | undefined): boolean {
    return proto3.util.equals(GetChunkResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetIndexesRequest
 */
export class GetIndexesRequest extends Message<GetIndexesRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<GetIndexesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetIndexesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIndexesRequest {
    return new GetIndexesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIndexesRequest | PlainMessage<GetIndexesRequest> | undefined, b: GetIndexesRequest | PlainMessage<GetIndexesRequest> | undefined): boolean {
    return proto3.util.equals(GetIndexesRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetIndexesResponse
 */
export class GetIndexesResponse extends Message<GetIndexesResponse> {
  /**
   * @generated from field: bool sealed = 1;
   */
  sealed = false;

  /**
   * @generated from field: repeated gastrolog.v1.IndexInfo indexes = 2;
   */
  indexes: IndexInfo[] = [];

  constructor(data?: PartialMessage<GetIndexesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetIndexesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "indexes", kind: "message", T: IndexInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIndexesResponse {
    return new GetIndexesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIndexesResponse | PlainMessage<GetIndexesResponse> | undefined, b: GetIndexesResponse | PlainMessage<GetIndexesResponse> | undefined): boolean {
    return proto3.util.equals(GetIndexesResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.IndexInfo
 */
export class IndexInfo extends Message<IndexInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: bool exists = 2;
   */
  exists = false;

  /**
   * @generated from field: int64 entry_count = 3;
   */
  entryCount = protoInt64.zero;

  /**
   * @generated from field: int64 size_bytes = 4;
   */
  sizeBytes = protoInt64.zero;

  constructor(data?: PartialMessage<IndexInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.IndexInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "entry_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexInfo {
    return new IndexInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexInfo {
    return new IndexInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexInfo {
    return new IndexInfo().fromJsonString(jsonString, options);
  }

  static equals(a: IndexInfo | PlainMessage<IndexInfo> | undefined, b: IndexInfo | PlainMessage<IndexInfo> | undefined): boolean {
    return proto3.util.equals(IndexInfo, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.AnalyzeChunkRequest
 */
export class AnalyzeChunkRequest extends Message<AnalyzeChunkRequest> {
  /**
   * @generated from field: string store = 1;
   */
  store = "";

  /**
   * If empty, analyze all chunks
   *
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  constructor(data?: PartialMessage<AnalyzeChunkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.AnalyzeChunkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeChunkRequest {
    return new AnalyzeChunkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeChunkRequest | PlainMessage<AnalyzeChunkRequest> | undefined, b: AnalyzeChunkRequest | PlainMessage<AnalyzeChunkRequest> | undefined): boolean {
    return proto3.util.equals(AnalyzeChunkRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.AnalyzeChunkResponse
 */
export class AnalyzeChunkResponse extends Message<AnalyzeChunkResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkAnalysis analyses = 1;
   */
  analyses: ChunkAnalysis[] = [];

  constructor(data?: PartialMessage<AnalyzeChunkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.AnalyzeChunkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "analyses", kind: "message", T: ChunkAnalysis, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeChunkResponse {
    return new AnalyzeChunkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeChunkResponse | PlainMessage<AnalyzeChunkResponse> | undefined, b: AnalyzeChunkResponse | PlainMessage<AnalyzeChunkResponse> | undefined): boolean {
    return proto3.util.equals(AnalyzeChunkResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkAnalysis
 */
export class ChunkAnalysis extends Message<ChunkAnalysis> {
  /**
   * @generated from field: string chunk_id = 1;
   */
  chunkId = "";

  /**
   * @generated from field: bool sealed = 2;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 3;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: repeated gastrolog.v1.IndexAnalysis indexes = 4;
   */
  indexes: IndexAnalysis[] = [];

  constructor(data?: PartialMessage<ChunkAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "indexes", kind: "message", T: IndexAnalysis, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkAnalysis {
    return new ChunkAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkAnalysis | PlainMessage<ChunkAnalysis> | undefined, b: ChunkAnalysis | PlainMessage<ChunkAnalysis> | undefined): boolean {
    return proto3.util.equals(ChunkAnalysis, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.IndexAnalysis
 */
export class IndexAnalysis extends Message<IndexAnalysis> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: bool complete = 2;
   */
  complete = false;

  /**
   * "ok", "missing", "incomplete", "capped"
   *
   * @generated from field: string status = 3;
   */
  status = "";

  /**
   * @generated from field: int64 entry_count = 4;
   */
  entryCount = protoInt64.zero;

  /**
   * 0.0 to 1.0
   *
   * @generated from field: double coverage = 5;
   */
  coverage = 0;

  /**
   * @generated from field: map<string, string> details = 6;
   */
  details: { [key: string]: string } = {};

  constructor(data?: PartialMessage<IndexAnalysis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.IndexAnalysis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "complete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "entry_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "coverage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "details", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexAnalysis {
    return new IndexAnalysis().fromJsonString(jsonString, options);
  }

  static equals(a: IndexAnalysis | PlainMessage<IndexAnalysis> | undefined, b: IndexAnalysis | PlainMessage<IndexAnalysis> | undefined): boolean {
    return proto3.util.equals(IndexAnalysis, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStatsRequest
 */
export class GetStatsRequest extends Message<GetStatsRequest> {
  /**
   * If empty, aggregate across all stores
   *
   * @generated from field: string store = 1;
   */
  store = "";

  constructor(data?: PartialMessage<GetStatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatsRequest {
    return new GetStatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatsRequest | PlainMessage<GetStatsRequest> | undefined, b: GetStatsRequest | PlainMessage<GetStatsRequest> | undefined): boolean {
    return proto3.util.equals(GetStatsRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetStatsResponse
 */
export class GetStatsResponse extends Message<GetStatsResponse> {
  /**
   * @generated from field: int64 total_stores = 1;
   */
  totalStores = protoInt64.zero;

  /**
   * @generated from field: int64 total_chunks = 2;
   */
  totalChunks = protoInt64.zero;

  /**
   * @generated from field: int64 sealed_chunks = 3;
   */
  sealedChunks = protoInt64.zero;

  /**
   * @generated from field: int64 total_records = 4;
   */
  totalRecords = protoInt64.zero;

  /**
   * @generated from field: int64 total_bytes = 5;
   */
  totalBytes = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp oldest_record = 6;
   */
  oldestRecord?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp newest_record = 7;
   */
  newestRecord?: Timestamp;

  constructor(data?: PartialMessage<GetStatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetStatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_stores", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "total_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "sealed_chunks", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "total_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "total_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "oldest_record", kind: "message", T: Timestamp },
    { no: 7, name: "newest_record", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatsResponse {
    return new GetStatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStatsResponse | PlainMessage<GetStatsResponse> | undefined, b: GetStatsResponse | PlainMessage<GetStatsResponse> | undefined): boolean {
    return proto3.util.equals(GetStatsResponse, a, b);
  }
}

