// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file gastrolog/v1/query.proto (package gastrolog.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message gastrolog.v1.SearchRequest
 */
export class SearchRequest extends Message<SearchRequest> {
  /**
   * @generated from field: gastrolog.v1.Query query = 2;
   */
  query?: Query;

  /**
   * Opaque token for pagination
   *
   * @generated from field: bytes resume_token = 3;
   */
  resumeToken = new Uint8Array(0);

  constructor(data?: PartialMessage<SearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.SearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "query", kind: "message", T: Query },
    { no: 3, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest {
    return new SearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRequest | PlainMessage<SearchRequest> | undefined, b: SearchRequest | PlainMessage<SearchRequest> | undefined): boolean {
    return proto3.util.equals(SearchRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.SearchResponse
 */
export class SearchResponse extends Message<SearchResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.Record records = 1;
   */
  records: Record[] = [];

  /**
   * Token to continue from, if more results exist
   *
   * @generated from field: bytes resume_token = 2;
   */
  resumeToken = new Uint8Array(0);

  /**
   * @generated from field: bool has_more = 3;
   */
  hasMore = false;

  /**
   * Set for pipeline queries (e.g. "error | stats count by level").
   * When present, records is empty; results are in table form.
   *
   * @generated from field: gastrolog.v1.TableResult table_result = 4;
   */
  tableResult?: TableResult;

  constructor(data?: PartialMessage<SearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.SearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records", kind: "message", T: Record, repeated: true },
    { no: 2, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "has_more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "table_result", kind: "message", T: TableResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse {
    return new SearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean {
    return proto3.util.equals(SearchResponse, a, b);
  }
}

/**
 * TableResult holds aggregated results from a pipeline stats operator.
 *
 * @generated from message gastrolog.v1.TableResult
 */
export class TableResult extends Message<TableResult> {
  /**
   * Column names in order (groups first, then aggregates)
   *
   * @generated from field: repeated string columns = 1;
   */
  columns: string[] = [];

  /**
   * Row data (same column order)
   *
   * @generated from field: repeated gastrolog.v1.TableRow rows = 2;
   */
  rows: TableRow[] = [];

  /**
   * True if cardinality cap was hit
   *
   * @generated from field: bool truncated = 3;
   */
  truncated = false;

  /**
   * "table" or "timeseries" (timeseries when bin() is used)
   *
   * @generated from field: string result_type = 4;
   */
  resultType = "";

  constructor(data?: PartialMessage<TableResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.TableResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "rows", kind: "message", T: TableRow, repeated: true },
    { no: 3, name: "truncated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "result_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableResult {
    return new TableResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableResult {
    return new TableResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableResult {
    return new TableResult().fromJsonString(jsonString, options);
  }

  static equals(a: TableResult | PlainMessage<TableResult> | undefined, b: TableResult | PlainMessage<TableResult> | undefined): boolean {
    return proto3.util.equals(TableResult, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.TableRow
 */
export class TableRow extends Message<TableRow> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<TableRow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.TableRow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableRow {
    return new TableRow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableRow {
    return new TableRow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableRow {
    return new TableRow().fromJsonString(jsonString, options);
  }

  static equals(a: TableRow | PlainMessage<TableRow> | undefined, b: TableRow | PlainMessage<TableRow> | undefined): boolean {
    return proto3.util.equals(TableRow, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.FollowRequest
 */
export class FollowRequest extends Message<FollowRequest> {
  /**
   * @generated from field: gastrolog.v1.Query query = 2;
   */
  query?: Query;

  constructor(data?: PartialMessage<FollowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.FollowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "query", kind: "message", T: Query },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FollowRequest {
    return new FollowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FollowRequest {
    return new FollowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FollowRequest {
    return new FollowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FollowRequest | PlainMessage<FollowRequest> | undefined, b: FollowRequest | PlainMessage<FollowRequest> | undefined): boolean {
    return proto3.util.equals(FollowRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.FollowResponse
 */
export class FollowResponse extends Message<FollowResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.Record records = 1;
   */
  records: Record[] = [];

  constructor(data?: PartialMessage<FollowResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.FollowResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records", kind: "message", T: Record, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FollowResponse {
    return new FollowResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FollowResponse {
    return new FollowResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FollowResponse {
    return new FollowResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FollowResponse | PlainMessage<FollowResponse> | undefined, b: FollowResponse | PlainMessage<FollowResponse> | undefined): boolean {
    return proto3.util.equals(FollowResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ExplainRequest
 */
export class ExplainRequest extends Message<ExplainRequest> {
  /**
   * @generated from field: gastrolog.v1.Query query = 2;
   */
  query?: Query;

  constructor(data?: PartialMessage<ExplainRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExplainRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "query", kind: "message", T: Query },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExplainRequest {
    return new ExplainRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExplainRequest {
    return new ExplainRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExplainRequest {
    return new ExplainRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExplainRequest | PlainMessage<ExplainRequest> | undefined, b: ExplainRequest | PlainMessage<ExplainRequest> | undefined): boolean {
    return proto3.util.equals(ExplainRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ExplainResponse
 */
export class ExplainResponse extends Message<ExplainResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkPlan chunks = 1;
   */
  chunks: ChunkPlan[] = [];

  /**
   * "forward" or "reverse"
   *
   * @generated from field: string direction = 2;
   */
  direction = "";

  /**
   * Total chunks before time-range filtering
   *
   * @generated from field: int32 total_chunks = 3;
   */
  totalChunks = 0;

  /**
   * Parsed boolean expression (from BoolExpr.String())
   *
   * @generated from field: string expression = 4;
   */
  expression = "";

  /**
   * Resolved query start time
   *
   * @generated from field: google.protobuf.Timestamp query_start = 5;
   */
  queryStart?: Timestamp;

  /**
   * Resolved query end time
   *
   * @generated from field: google.protobuf.Timestamp query_end = 6;
   */
  queryEnd?: Timestamp;

  constructor(data?: PartialMessage<ExplainResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExplainResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks", kind: "message", T: ChunkPlan, repeated: true },
    { no: 2, name: "direction", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_chunks", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "query_start", kind: "message", T: Timestamp },
    { no: 6, name: "query_end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExplainResponse {
    return new ExplainResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExplainResponse {
    return new ExplainResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExplainResponse {
    return new ExplainResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExplainResponse | PlainMessage<ExplainResponse> | undefined, b: ExplainResponse | PlainMessage<ExplainResponse> | undefined): boolean {
    return proto3.util.equals(ExplainResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.Query
 */
export class Query extends Message<Query> {
  /**
   * @generated from field: google.protobuf.Timestamp start = 1;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 2;
   */
  end?: Timestamp;

  /**
   * @generated from field: repeated string tokens = 3;
   */
  tokens: string[] = [];

  /**
   * @generated from field: repeated gastrolog.v1.KVPredicate kv_predicates = 4;
   */
  kvPredicates: KVPredicate[] = [];

  /**
   * @generated from field: int64 limit = 5;
   */
  limit = protoInt64.zero;

  /**
   * @generated from field: int32 context_before = 6;
   */
  contextBefore = 0;

  /**
   * @generated from field: int32 context_after = 7;
   */
  contextAfter = 0;

  /**
   * Raw query expression string, parsed server-side via querylang.
   * When set, tokens and kv_predicates are ignored.
   * Supports the full query language: bare words (tokens), key=value,
   * AND/OR/NOT, parentheses, start=/end=/limit= control args.
   * Examples: "error timeout", "(error OR warn) AND NOT debug",
   *           "start=2024-01-01T00:00:00Z level=error store=prod"
   *
   * @generated from field: string expression = 8;
   */
  expression = "";

  constructor(data?: PartialMessage<Query>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.Query";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Timestamp },
    { no: 2, name: "end", kind: "message", T: Timestamp },
    { no: 3, name: "tokens", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "kv_predicates", kind: "message", T: KVPredicate, repeated: true },
    { no: 5, name: "limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "context_before", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "context_after", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query {
    return new Query().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJsonString(jsonString, options);
  }

  static equals(a: Query | PlainMessage<Query> | undefined, b: Query | PlainMessage<Query> | undefined): boolean {
    return proto3.util.equals(Query, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.KVPredicate
 */
export class KVPredicate extends Message<KVPredicate> {
  /**
   * Empty for value-exists check
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Empty for key-exists check, "*" also means any
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<KVPredicate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.KVPredicate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KVPredicate {
    return new KVPredicate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KVPredicate {
    return new KVPredicate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KVPredicate {
    return new KVPredicate().fromJsonString(jsonString, options);
  }

  static equals(a: KVPredicate | PlainMessage<KVPredicate> | undefined, b: KVPredicate | PlainMessage<KVPredicate> | undefined): boolean {
    return proto3.util.equals(KVPredicate, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.Record
 */
export class Record extends Message<Record> {
  /**
   * @generated from field: google.protobuf.Timestamp ingest_ts = 1;
   */
  ingestTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp write_ts = 2;
   */
  writeTs?: Timestamp;

  /**
   * @generated from field: map<string, string> attrs = 3;
   */
  attrs: { [key: string]: string } = {};

  /**
   * @generated from field: bytes raw = 4;
   */
  raw = new Uint8Array(0);

  /**
   * @generated from field: gastrolog.v1.RecordRef ref = 5;
   */
  ref?: RecordRef;

  /**
   * @generated from field: google.protobuf.Timestamp source_ts = 6;
   */
  sourceTs?: Timestamp;

  constructor(data?: PartialMessage<Record>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.Record";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ingest_ts", kind: "message", T: Timestamp },
    { no: 2, name: "write_ts", kind: "message", T: Timestamp },
    { no: 3, name: "attrs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "raw", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "ref", kind: "message", T: RecordRef },
    { no: 6, name: "source_ts", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Record {
    return new Record().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Record {
    return new Record().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Record {
    return new Record().fromJsonString(jsonString, options);
  }

  static equals(a: Record | PlainMessage<Record> | undefined, b: Record | PlainMessage<Record> | undefined): boolean {
    return proto3.util.equals(Record, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.RecordRef
 */
export class RecordRef extends Message<RecordRef> {
  /**
   * @generated from field: string chunk_id = 1;
   */
  chunkId = "";

  /**
   * @generated from field: uint64 pos = 2;
   */
  pos = protoInt64.zero;

  /**
   * Store this record belongs to
   *
   * @generated from field: string store_id = 3;
   */
  storeId = "";

  constructor(data?: PartialMessage<RecordRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.RecordRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pos", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "store_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordRef {
    return new RecordRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordRef {
    return new RecordRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordRef {
    return new RecordRef().fromJsonString(jsonString, options);
  }

  static equals(a: RecordRef | PlainMessage<RecordRef> | undefined, b: RecordRef | PlainMessage<RecordRef> | undefined): boolean {
    return proto3.util.equals(RecordRef, a, b);
  }
}

/**
 * ResumeToken encodes pagination state for multi-store queries.
 * The positions array tracks the last returned position for each store/chunk.
 *
 * @generated from message gastrolog.v1.ResumeToken
 */
export class ResumeToken extends Message<ResumeToken> {
  /**
   * @generated from field: repeated gastrolog.v1.StorePosition positions = 1;
   */
  positions: StorePosition[] = [];

  constructor(data?: PartialMessage<ResumeToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ResumeToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "positions", kind: "message", T: StorePosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResumeToken {
    return new ResumeToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResumeToken {
    return new ResumeToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResumeToken {
    return new ResumeToken().fromJsonString(jsonString, options);
  }

  static equals(a: ResumeToken | PlainMessage<ResumeToken> | undefined, b: ResumeToken | PlainMessage<ResumeToken> | undefined): boolean {
    return proto3.util.equals(ResumeToken, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.StorePosition
 */
export class StorePosition extends Message<StorePosition> {
  /**
   * @generated from field: string store_id = 1;
   */
  storeId = "";

  /**
   * @generated from field: string chunk_id = 2;
   */
  chunkId = "";

  /**
   * MaxUint64 indicates chunk is exhausted
   *
   * @generated from field: uint64 position = 3;
   */
  position = protoInt64.zero;

  constructor(data?: PartialMessage<StorePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.StorePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorePosition {
    return new StorePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorePosition {
    return new StorePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorePosition {
    return new StorePosition().fromJsonString(jsonString, options);
  }

  static equals(a: StorePosition | PlainMessage<StorePosition> | undefined, b: StorePosition | PlainMessage<StorePosition> | undefined): boolean {
    return proto3.util.equals(StorePosition, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkPlan
 */
export class ChunkPlan extends Message<ChunkPlan> {
  /**
   * @generated from field: string chunk_id = 1;
   */
  chunkId = "";

  /**
   * @generated from field: bool sealed = 2;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 3;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: repeated gastrolog.v1.PipelineStep steps = 4;
   */
  steps: PipelineStep[] = [];

  /**
   * "sequential", "index-driven", or "skipped"
   *
   * @generated from field: string scan_mode = 5;
   */
  scanMode = "";

  /**
   * @generated from field: int64 estimated_records = 6;
   */
  estimatedRecords = protoInt64.zero;

  /**
   * @generated from field: repeated string runtime_filters = 7;
   */
  runtimeFilters: string[] = [];

  /**
   * @generated from field: string store_id = 8;
   */
  storeId = "";

  /**
   * @generated from field: google.protobuf.Timestamp start_ts = 9;
   */
  startTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_ts = 10;
   */
  endTs?: Timestamp;

  /**
   * @generated from field: string skip_reason = 11;
   */
  skipReason = "";

  /**
   * @generated from field: repeated gastrolog.v1.BranchPlan branch_plans = 12;
   */
  branchPlans: BranchPlan[] = [];

  constructor(data?: PartialMessage<ChunkPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "steps", kind: "message", T: PipelineStep, repeated: true },
    { no: 5, name: "scan_mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "estimated_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "runtime_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "store_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "start_ts", kind: "message", T: Timestamp },
    { no: 10, name: "end_ts", kind: "message", T: Timestamp },
    { no: 11, name: "skip_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "branch_plans", kind: "message", T: BranchPlan, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkPlan {
    return new ChunkPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkPlan {
    return new ChunkPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkPlan {
    return new ChunkPlan().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkPlan | PlainMessage<ChunkPlan> | undefined, b: ChunkPlan | PlainMessage<ChunkPlan> | undefined): boolean {
    return proto3.util.equals(ChunkPlan, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.BranchPlan
 */
export class BranchPlan extends Message<BranchPlan> {
  /**
   * String representation of the branch
   *
   * @generated from field: string expression = 1;
   */
  expression = "";

  /**
   * @generated from field: repeated gastrolog.v1.PipelineStep steps = 2;
   */
  steps: PipelineStep[] = [];

  /**
   * @generated from field: bool skipped = 3;
   */
  skipped = false;

  /**
   * @generated from field: string skip_reason = 4;
   */
  skipReason = "";

  /**
   * @generated from field: int64 estimated_records = 5;
   */
  estimatedRecords = protoInt64.zero;

  constructor(data?: PartialMessage<BranchPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.BranchPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "steps", kind: "message", T: PipelineStep, repeated: true },
    { no: 3, name: "skipped", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "skip_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "estimated_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BranchPlan {
    return new BranchPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BranchPlan {
    return new BranchPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BranchPlan {
    return new BranchPlan().fromJsonString(jsonString, options);
  }

  static equals(a: BranchPlan | PlainMessage<BranchPlan> | undefined, b: BranchPlan | PlainMessage<BranchPlan> | undefined): boolean {
    return proto3.util.equals(BranchPlan, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.PipelineStep
 */
export class PipelineStep extends Message<PipelineStep> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: int64 input_estimate = 2;
   */
  inputEstimate = protoInt64.zero;

  /**
   * @generated from field: int64 output_estimate = 3;
   */
  outputEstimate = protoInt64.zero;

  /**
   * "seek", "indexed", "runtime", "skipped"
   *
   * @generated from field: string action = 4;
   */
  action = "";

  /**
   * @generated from field: string reason = 5;
   */
  reason = "";

  /**
   * @generated from field: string detail = 6;
   */
  detail = "";

  /**
   * What we're filtering for, e.g. "token(error, warn)"
   *
   * @generated from field: string predicate = 7;
   */
  predicate = "";

  constructor(data?: PartialMessage<PipelineStep>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.PipelineStep";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "input_estimate", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "output_estimate", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "action", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "predicate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PipelineStep {
    return new PipelineStep().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PipelineStep {
    return new PipelineStep().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PipelineStep {
    return new PipelineStep().fromJsonString(jsonString, options);
  }

  static equals(a: PipelineStep | PlainMessage<PipelineStep> | undefined, b: PipelineStep | PlainMessage<PipelineStep> | undefined): boolean {
    return proto3.util.equals(PipelineStep, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.HistogramRequest
 */
export class HistogramRequest extends Message<HistogramRequest> {
  /**
   * @generated from field: google.protobuf.Timestamp start = 1;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 2;
   */
  end?: Timestamp;

  /**
   * Number of time buckets (default 50 if 0)
   *
   * @generated from field: int32 buckets = 3;
   */
  buckets = 0;

  /**
   * Optional: only used to extract store= filter
   *
   * @generated from field: string expression = 4;
   */
  expression = "";

  constructor(data?: PartialMessage<HistogramRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.HistogramRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Timestamp },
    { no: 2, name: "end", kind: "message", T: Timestamp },
    { no: 3, name: "buckets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistogramRequest {
    return new HistogramRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistogramRequest {
    return new HistogramRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistogramRequest {
    return new HistogramRequest().fromJsonString(jsonString, options);
  }

  static equals(a: HistogramRequest | PlainMessage<HistogramRequest> | undefined, b: HistogramRequest | PlainMessage<HistogramRequest> | undefined): boolean {
    return proto3.util.equals(HistogramRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.HistogramResponse
 */
export class HistogramResponse extends Message<HistogramResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.HistogramBucket buckets = 1;
   */
  buckets: HistogramBucket[] = [];

  /**
   * Actual start of histogram range
   *
   * @generated from field: google.protobuf.Timestamp start = 2;
   */
  start?: Timestamp;

  /**
   * Actual end of histogram range
   *
   * @generated from field: google.protobuf.Timestamp end = 3;
   */
  end?: Timestamp;

  constructor(data?: PartialMessage<HistogramResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.HistogramResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "buckets", kind: "message", T: HistogramBucket, repeated: true },
    { no: 2, name: "start", kind: "message", T: Timestamp },
    { no: 3, name: "end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistogramResponse {
    return new HistogramResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistogramResponse {
    return new HistogramResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistogramResponse {
    return new HistogramResponse().fromJsonString(jsonString, options);
  }

  static equals(a: HistogramResponse | PlainMessage<HistogramResponse> | undefined, b: HistogramResponse | PlainMessage<HistogramResponse> | undefined): boolean {
    return proto3.util.equals(HistogramResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.HistogramBucket
 */
export class HistogramBucket extends Message<HistogramBucket> {
  /**
   * Bucket start time
   *
   * @generated from field: google.protobuf.Timestamp ts = 1;
   */
  ts?: Timestamp;

  /**
   * Record count in this bucket
   *
   * @generated from field: int64 count = 2;
   */
  count = protoInt64.zero;

  /**
   * Per-severity counts, e.g. {"error": 12, "warn": 45}
   *
   * @generated from field: map<string, int64> level_counts = 3;
   */
  levelCounts: { [key: string]: bigint } = {};

  constructor(data?: PartialMessage<HistogramBucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.HistogramBucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ts", kind: "message", T: Timestamp },
    { no: 2, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "level_counts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 3 /* ScalarType.INT64 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistogramBucket {
    return new HistogramBucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistogramBucket {
    return new HistogramBucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistogramBucket {
    return new HistogramBucket().fromJsonString(jsonString, options);
  }

  static equals(a: HistogramBucket | PlainMessage<HistogramBucket> | undefined, b: HistogramBucket | PlainMessage<HistogramBucket> | undefined): boolean {
    return proto3.util.equals(HistogramBucket, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetContextRequest
 */
export class GetContextRequest extends Message<GetContextRequest> {
  /**
   * The anchor record
   *
   * @generated from field: gastrolog.v1.RecordRef ref = 1;
   */
  ref?: RecordRef;

  /**
   * Number of records before anchor (default 5, max 50)
   *
   * @generated from field: int32 before = 2;
   */
  before = 0;

  /**
   * Number of records after anchor (default 5, max 50)
   *
   * @generated from field: int32 after = 3;
   */
  after = 0;

  constructor(data?: PartialMessage<GetContextRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetContextRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ref", kind: "message", T: RecordRef },
    { no: 2, name: "before", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "after", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetContextRequest {
    return new GetContextRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetContextRequest {
    return new GetContextRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetContextRequest {
    return new GetContextRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetContextRequest | PlainMessage<GetContextRequest> | undefined, b: GetContextRequest | PlainMessage<GetContextRequest> | undefined): boolean {
    return proto3.util.equals(GetContextRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetContextResponse
 */
export class GetContextResponse extends Message<GetContextResponse> {
  /**
   * Records before anchor, oldest first, all stores
   *
   * @generated from field: repeated gastrolog.v1.Record before = 1;
   */
  before: Record[] = [];

  /**
   * The anchor record itself
   *
   * @generated from field: gastrolog.v1.Record anchor = 2;
   */
  anchor?: Record;

  /**
   * Records after anchor, oldest first, all stores
   *
   * @generated from field: repeated gastrolog.v1.Record after = 3;
   */
  after: Record[] = [];

  constructor(data?: PartialMessage<GetContextResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetContextResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "before", kind: "message", T: Record, repeated: true },
    { no: 2, name: "anchor", kind: "message", T: Record },
    { no: 3, name: "after", kind: "message", T: Record, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetContextResponse {
    return new GetContextResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetContextResponse {
    return new GetContextResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetContextResponse {
    return new GetContextResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetContextResponse | PlainMessage<GetContextResponse> | undefined, b: GetContextResponse | PlainMessage<GetContextResponse> | undefined): boolean {
    return proto3.util.equals(GetContextResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetSyntaxRequest
 */
export class GetSyntaxRequest extends Message<GetSyntaxRequest> {
  constructor(data?: PartialMessage<GetSyntaxRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetSyntaxRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSyntaxRequest {
    return new GetSyntaxRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSyntaxRequest {
    return new GetSyntaxRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSyntaxRequest {
    return new GetSyntaxRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSyntaxRequest | PlainMessage<GetSyntaxRequest> | undefined, b: GetSyntaxRequest | PlainMessage<GetSyntaxRequest> | undefined): boolean {
    return proto3.util.equals(GetSyntaxRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.GetSyntaxResponse
 */
export class GetSyntaxResponse extends Message<GetSyntaxResponse> {
  /**
   * Query control args (reverse, start, end, last, ...)
   *
   * @generated from field: repeated string directives = 1;
   */
  directives: string[] = [];

  /**
   * Pipe operator keywords (stats, where)
   *
   * @generated from field: repeated string pipe_keywords = 2;
   */
  pipeKeywords: string[] = [];

  /**
   * Functions usable in pipe expressions (count, avg, bin, ...)
   *
   * @generated from field: repeated string pipe_functions = 3;
   */
  pipeFunctions: string[] = [];

  constructor(data?: PartialMessage<GetSyntaxResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.GetSyntaxResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "directives", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "pipe_keywords", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "pipe_functions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSyntaxResponse {
    return new GetSyntaxResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSyntaxResponse {
    return new GetSyntaxResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSyntaxResponse {
    return new GetSyntaxResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSyntaxResponse | PlainMessage<GetSyntaxResponse> | undefined, b: GetSyntaxResponse | PlainMessage<GetSyntaxResponse> | undefined): boolean {
    return proto3.util.equals(GetSyntaxResponse, a, b);
  }
}

