// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file gastrolog/v1/query.proto (package gastrolog.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message gastrolog.v1.SearchRequest
 */
export class SearchRequest extends Message<SearchRequest> {
  /**
   * @generated from field: gastrolog.v1.Query query = 2;
   */
  query?: Query;

  /**
   * Opaque token for pagination
   *
   * @generated from field: bytes resume_token = 3;
   */
  resumeToken = new Uint8Array(0);

  constructor(data?: PartialMessage<SearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.SearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "query", kind: "message", T: Query },
    { no: 3, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRequest {
    return new SearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRequest {
    return new SearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRequest | PlainMessage<SearchRequest> | undefined, b: SearchRequest | PlainMessage<SearchRequest> | undefined): boolean {
    return proto3.util.equals(SearchRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.SearchResponse
 */
export class SearchResponse extends Message<SearchResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.Record records = 1;
   */
  records: Record[] = [];

  /**
   * Token to continue from, if more results exist
   *
   * @generated from field: bytes resume_token = 2;
   */
  resumeToken = new Uint8Array(0);

  /**
   * @generated from field: bool has_more = 3;
   */
  hasMore = false;

  constructor(data?: PartialMessage<SearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.SearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records", kind: "message", T: Record, repeated: true },
    { no: 2, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "has_more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse {
    return new SearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean {
    return proto3.util.equals(SearchResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.FollowRequest
 */
export class FollowRequest extends Message<FollowRequest> {
  /**
   * @generated from field: gastrolog.v1.Query query = 2;
   */
  query?: Query;

  constructor(data?: PartialMessage<FollowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.FollowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "query", kind: "message", T: Query },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FollowRequest {
    return new FollowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FollowRequest {
    return new FollowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FollowRequest {
    return new FollowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FollowRequest | PlainMessage<FollowRequest> | undefined, b: FollowRequest | PlainMessage<FollowRequest> | undefined): boolean {
    return proto3.util.equals(FollowRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.FollowResponse
 */
export class FollowResponse extends Message<FollowResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.Record records = 1;
   */
  records: Record[] = [];

  constructor(data?: PartialMessage<FollowResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.FollowResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records", kind: "message", T: Record, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FollowResponse {
    return new FollowResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FollowResponse {
    return new FollowResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FollowResponse {
    return new FollowResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FollowResponse | PlainMessage<FollowResponse> | undefined, b: FollowResponse | PlainMessage<FollowResponse> | undefined): boolean {
    return proto3.util.equals(FollowResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ExplainRequest
 */
export class ExplainRequest extends Message<ExplainRequest> {
  /**
   * @generated from field: gastrolog.v1.Query query = 2;
   */
  query?: Query;

  constructor(data?: PartialMessage<ExplainRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExplainRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "query", kind: "message", T: Query },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExplainRequest {
    return new ExplainRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExplainRequest {
    return new ExplainRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExplainRequest {
    return new ExplainRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExplainRequest | PlainMessage<ExplainRequest> | undefined, b: ExplainRequest | PlainMessage<ExplainRequest> | undefined): boolean {
    return proto3.util.equals(ExplainRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ExplainResponse
 */
export class ExplainResponse extends Message<ExplainResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.ChunkPlan chunks = 1;
   */
  chunks: ChunkPlan[] = [];

  /**
   * "forward" or "reverse"
   *
   * @generated from field: string direction = 2;
   */
  direction = "";

  /**
   * Total chunks before time-range filtering
   *
   * @generated from field: int32 total_chunks = 3;
   */
  totalChunks = 0;

  /**
   * Parsed boolean expression (from BoolExpr.String())
   *
   * @generated from field: string expression = 4;
   */
  expression = "";

  constructor(data?: PartialMessage<ExplainResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ExplainResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks", kind: "message", T: ChunkPlan, repeated: true },
    { no: 2, name: "direction", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_chunks", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExplainResponse {
    return new ExplainResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExplainResponse {
    return new ExplainResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExplainResponse {
    return new ExplainResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExplainResponse | PlainMessage<ExplainResponse> | undefined, b: ExplainResponse | PlainMessage<ExplainResponse> | undefined): boolean {
    return proto3.util.equals(ExplainResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.Query
 */
export class Query extends Message<Query> {
  /**
   * @generated from field: google.protobuf.Timestamp start = 1;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 2;
   */
  end?: Timestamp;

  /**
   * @generated from field: repeated string tokens = 3;
   */
  tokens: string[] = [];

  /**
   * @generated from field: repeated gastrolog.v1.KVPredicate kv_predicates = 4;
   */
  kvPredicates: KVPredicate[] = [];

  /**
   * @generated from field: int64 limit = 5;
   */
  limit = protoInt64.zero;

  /**
   * @generated from field: int32 context_before = 6;
   */
  contextBefore = 0;

  /**
   * @generated from field: int32 context_after = 7;
   */
  contextAfter = 0;

  /**
   * Raw query expression string, parsed server-side via querylang.
   * When set, tokens and kv_predicates are ignored.
   * Supports the full query language: bare words (tokens), key=value,
   * AND/OR/NOT, parentheses, start=/end=/limit= control args.
   * Examples: "error timeout", "(error OR warn) AND NOT debug",
   *           "start=2024-01-01T00:00:00Z level=error store=prod"
   *
   * @generated from field: string expression = 8;
   */
  expression = "";

  constructor(data?: PartialMessage<Query>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.Query";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Timestamp },
    { no: 2, name: "end", kind: "message", T: Timestamp },
    { no: 3, name: "tokens", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "kv_predicates", kind: "message", T: KVPredicate, repeated: true },
    { no: 5, name: "limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "context_before", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "context_after", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query {
    return new Query().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJsonString(jsonString, options);
  }

  static equals(a: Query | PlainMessage<Query> | undefined, b: Query | PlainMessage<Query> | undefined): boolean {
    return proto3.util.equals(Query, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.KVPredicate
 */
export class KVPredicate extends Message<KVPredicate> {
  /**
   * Empty for value-exists check
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Empty for key-exists check, "*" also means any
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<KVPredicate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.KVPredicate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KVPredicate {
    return new KVPredicate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KVPredicate {
    return new KVPredicate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KVPredicate {
    return new KVPredicate().fromJsonString(jsonString, options);
  }

  static equals(a: KVPredicate | PlainMessage<KVPredicate> | undefined, b: KVPredicate | PlainMessage<KVPredicate> | undefined): boolean {
    return proto3.util.equals(KVPredicate, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.Record
 */
export class Record extends Message<Record> {
  /**
   * @generated from field: google.protobuf.Timestamp ingest_ts = 1;
   */
  ingestTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp write_ts = 2;
   */
  writeTs?: Timestamp;

  /**
   * @generated from field: map<string, string> attrs = 3;
   */
  attrs: { [key: string]: string } = {};

  /**
   * @generated from field: bytes raw = 4;
   */
  raw = new Uint8Array(0);

  /**
   * @generated from field: gastrolog.v1.RecordRef ref = 5;
   */
  ref?: RecordRef;

  constructor(data?: PartialMessage<Record>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.Record";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ingest_ts", kind: "message", T: Timestamp },
    { no: 2, name: "write_ts", kind: "message", T: Timestamp },
    { no: 3, name: "attrs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "raw", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "ref", kind: "message", T: RecordRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Record {
    return new Record().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Record {
    return new Record().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Record {
    return new Record().fromJsonString(jsonString, options);
  }

  static equals(a: Record | PlainMessage<Record> | undefined, b: Record | PlainMessage<Record> | undefined): boolean {
    return proto3.util.equals(Record, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.RecordRef
 */
export class RecordRef extends Message<RecordRef> {
  /**
   * 16-byte UUID
   *
   * @generated from field: bytes chunk_id = 1;
   */
  chunkId = new Uint8Array(0);

  /**
   * @generated from field: uint64 pos = 2;
   */
  pos = protoInt64.zero;

  /**
   * Store this record belongs to
   *
   * @generated from field: string store_id = 3;
   */
  storeId = "";

  constructor(data?: PartialMessage<RecordRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.RecordRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "pos", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "store_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordRef {
    return new RecordRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordRef {
    return new RecordRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordRef {
    return new RecordRef().fromJsonString(jsonString, options);
  }

  static equals(a: RecordRef | PlainMessage<RecordRef> | undefined, b: RecordRef | PlainMessage<RecordRef> | undefined): boolean {
    return proto3.util.equals(RecordRef, a, b);
  }
}

/**
 * ResumeToken encodes pagination state for multi-store queries.
 * The positions array tracks the last returned position for each store/chunk.
 *
 * @generated from message gastrolog.v1.ResumeToken
 */
export class ResumeToken extends Message<ResumeToken> {
  /**
   * @generated from field: repeated gastrolog.v1.StorePosition positions = 1;
   */
  positions: StorePosition[] = [];

  constructor(data?: PartialMessage<ResumeToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ResumeToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "positions", kind: "message", T: StorePosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResumeToken {
    return new ResumeToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResumeToken {
    return new ResumeToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResumeToken {
    return new ResumeToken().fromJsonString(jsonString, options);
  }

  static equals(a: ResumeToken | PlainMessage<ResumeToken> | undefined, b: ResumeToken | PlainMessage<ResumeToken> | undefined): boolean {
    return proto3.util.equals(ResumeToken, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.StorePosition
 */
export class StorePosition extends Message<StorePosition> {
  /**
   * @generated from field: string store_id = 1;
   */
  storeId = "";

  /**
   * 16-byte UUID
   *
   * @generated from field: bytes chunk_id = 2;
   */
  chunkId = new Uint8Array(0);

  /**
   * MaxUint64 indicates chunk is exhausted
   *
   * @generated from field: uint64 position = 3;
   */
  position = protoInt64.zero;

  constructor(data?: PartialMessage<StorePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.StorePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "store_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "chunk_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorePosition {
    return new StorePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorePosition {
    return new StorePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorePosition {
    return new StorePosition().fromJsonString(jsonString, options);
  }

  static equals(a: StorePosition | PlainMessage<StorePosition> | undefined, b: StorePosition | PlainMessage<StorePosition> | undefined): boolean {
    return proto3.util.equals(StorePosition, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.ChunkPlan
 */
export class ChunkPlan extends Message<ChunkPlan> {
  /**
   * @generated from field: bytes chunk_id = 1;
   */
  chunkId = new Uint8Array(0);

  /**
   * @generated from field: bool sealed = 2;
   */
  sealed = false;

  /**
   * @generated from field: int64 record_count = 3;
   */
  recordCount = protoInt64.zero;

  /**
   * @generated from field: repeated gastrolog.v1.PipelineStep steps = 4;
   */
  steps: PipelineStep[] = [];

  /**
   * "sequential", "index-driven", or "skipped"
   *
   * @generated from field: string scan_mode = 5;
   */
  scanMode = "";

  /**
   * @generated from field: int64 estimated_records = 6;
   */
  estimatedRecords = protoInt64.zero;

  /**
   * @generated from field: repeated string runtime_filters = 7;
   */
  runtimeFilters: string[] = [];

  /**
   * @generated from field: string store_id = 8;
   */
  storeId = "";

  /**
   * @generated from field: google.protobuf.Timestamp start_ts = 9;
   */
  startTs?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_ts = 10;
   */
  endTs?: Timestamp;

  /**
   * @generated from field: string skip_reason = 11;
   */
  skipReason = "";

  /**
   * @generated from field: repeated gastrolog.v1.BranchPlan branch_plans = 12;
   */
  branchPlans: BranchPlan[] = [];

  constructor(data?: PartialMessage<ChunkPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.ChunkPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "record_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "steps", kind: "message", T: PipelineStep, repeated: true },
    { no: 5, name: "scan_mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "estimated_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "runtime_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "store_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "start_ts", kind: "message", T: Timestamp },
    { no: 10, name: "end_ts", kind: "message", T: Timestamp },
    { no: 11, name: "skip_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "branch_plans", kind: "message", T: BranchPlan, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkPlan {
    return new ChunkPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkPlan {
    return new ChunkPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkPlan {
    return new ChunkPlan().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkPlan | PlainMessage<ChunkPlan> | undefined, b: ChunkPlan | PlainMessage<ChunkPlan> | undefined): boolean {
    return proto3.util.equals(ChunkPlan, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.BranchPlan
 */
export class BranchPlan extends Message<BranchPlan> {
  /**
   * String representation of the branch
   *
   * @generated from field: string expression = 1;
   */
  expression = "";

  /**
   * @generated from field: repeated gastrolog.v1.PipelineStep steps = 2;
   */
  steps: PipelineStep[] = [];

  /**
   * @generated from field: bool skipped = 3;
   */
  skipped = false;

  /**
   * @generated from field: string skip_reason = 4;
   */
  skipReason = "";

  /**
   * @generated from field: int64 estimated_records = 5;
   */
  estimatedRecords = protoInt64.zero;

  constructor(data?: PartialMessage<BranchPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.BranchPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "steps", kind: "message", T: PipelineStep, repeated: true },
    { no: 3, name: "skipped", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "skip_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "estimated_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BranchPlan {
    return new BranchPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BranchPlan {
    return new BranchPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BranchPlan {
    return new BranchPlan().fromJsonString(jsonString, options);
  }

  static equals(a: BranchPlan | PlainMessage<BranchPlan> | undefined, b: BranchPlan | PlainMessage<BranchPlan> | undefined): boolean {
    return proto3.util.equals(BranchPlan, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.PipelineStep
 */
export class PipelineStep extends Message<PipelineStep> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: int64 input_estimate = 2;
   */
  inputEstimate = protoInt64.zero;

  /**
   * @generated from field: int64 output_estimate = 3;
   */
  outputEstimate = protoInt64.zero;

  /**
   * "seek", "indexed", "runtime", "skipped"
   *
   * @generated from field: string action = 4;
   */
  action = "";

  /**
   * @generated from field: string reason = 5;
   */
  reason = "";

  /**
   * @generated from field: string detail = 6;
   */
  detail = "";

  /**
   * What we're filtering for, e.g. "token(error, warn)"
   *
   * @generated from field: string predicate = 7;
   */
  predicate = "";

  constructor(data?: PartialMessage<PipelineStep>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.PipelineStep";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "input_estimate", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "output_estimate", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "action", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "predicate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PipelineStep {
    return new PipelineStep().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PipelineStep {
    return new PipelineStep().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PipelineStep {
    return new PipelineStep().fromJsonString(jsonString, options);
  }

  static equals(a: PipelineStep | PlainMessage<PipelineStep> | undefined, b: PipelineStep | PlainMessage<PipelineStep> | undefined): boolean {
    return proto3.util.equals(PipelineStep, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.HistogramRequest
 */
export class HistogramRequest extends Message<HistogramRequest> {
  /**
   * @generated from field: google.protobuf.Timestamp start = 1;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 2;
   */
  end?: Timestamp;

  /**
   * Number of time buckets (default 50 if 0)
   *
   * @generated from field: int32 buckets = 3;
   */
  buckets = 0;

  /**
   * Optional: only used to extract store= filter
   *
   * @generated from field: string expression = 4;
   */
  expression = "";

  constructor(data?: PartialMessage<HistogramRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.HistogramRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Timestamp },
    { no: 2, name: "end", kind: "message", T: Timestamp },
    { no: 3, name: "buckets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistogramRequest {
    return new HistogramRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistogramRequest {
    return new HistogramRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistogramRequest {
    return new HistogramRequest().fromJsonString(jsonString, options);
  }

  static equals(a: HistogramRequest | PlainMessage<HistogramRequest> | undefined, b: HistogramRequest | PlainMessage<HistogramRequest> | undefined): boolean {
    return proto3.util.equals(HistogramRequest, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.HistogramResponse
 */
export class HistogramResponse extends Message<HistogramResponse> {
  /**
   * @generated from field: repeated gastrolog.v1.HistogramBucket buckets = 1;
   */
  buckets: HistogramBucket[] = [];

  /**
   * Actual start of histogram range
   *
   * @generated from field: google.protobuf.Timestamp start = 2;
   */
  start?: Timestamp;

  /**
   * Actual end of histogram range
   *
   * @generated from field: google.protobuf.Timestamp end = 3;
   */
  end?: Timestamp;

  constructor(data?: PartialMessage<HistogramResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.HistogramResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "buckets", kind: "message", T: HistogramBucket, repeated: true },
    { no: 2, name: "start", kind: "message", T: Timestamp },
    { no: 3, name: "end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistogramResponse {
    return new HistogramResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistogramResponse {
    return new HistogramResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistogramResponse {
    return new HistogramResponse().fromJsonString(jsonString, options);
  }

  static equals(a: HistogramResponse | PlainMessage<HistogramResponse> | undefined, b: HistogramResponse | PlainMessage<HistogramResponse> | undefined): boolean {
    return proto3.util.equals(HistogramResponse, a, b);
  }
}

/**
 * @generated from message gastrolog.v1.HistogramBucket
 */
export class HistogramBucket extends Message<HistogramBucket> {
  /**
   * Bucket start time
   *
   * @generated from field: google.protobuf.Timestamp ts = 1;
   */
  ts?: Timestamp;

  /**
   * Record count in this bucket
   *
   * @generated from field: int64 count = 2;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<HistogramBucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gastrolog.v1.HistogramBucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ts", kind: "message", T: Timestamp },
    { no: 2, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistogramBucket {
    return new HistogramBucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistogramBucket {
    return new HistogramBucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistogramBucket {
    return new HistogramBucket().fromJsonString(jsonString, options);
  }

  static equals(a: HistogramBucket | PlainMessage<HistogramBucket> | undefined, b: HistogramBucket | PlainMessage<HistogramBucket> | undefined): boolean {
    return proto3.util.equals(HistogramBucket, a, b);
  }
}

