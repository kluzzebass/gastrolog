syntax = "proto3";

package gastrolog.v1;

option go_package = "gastrolog/api/gen/gastrolog/v1;gastrologv1";

import "google/protobuf/timestamp.proto";

// QueryService provides log querying capabilities.
service QueryService {
  // Search executes a query and streams matching records.
  rpc Search(SearchRequest) returns (stream SearchResponse);

  // Follow executes a query and streams matching records, then continues
  // streaming new records as they arrive (like tail -f).
  rpc Follow(FollowRequest) returns (stream FollowResponse);

  // Explain returns the query execution plan without executing.
  rpc Explain(ExplainRequest) returns (ExplainResponse);

  // GetContext returns records surrounding a specific record, across all stores.
  // Uses the anchor record's write timestamp to find nearby records.
  rpc GetContext(GetContextRequest) returns (GetContextResponse);

  // GetSyntax returns the query language keyword sets for frontend tokenization.
  // Called once at startup so the frontend stays in sync with the backend.
  rpc GetSyntax(GetSyntaxRequest) returns (GetSyntaxResponse);
}

message SearchRequest {
  // store field removed - use store=X in query expression instead
  reserved 1;
  reserved "store";
  Query query = 2;
  bytes resume_token = 3; // Opaque token for pagination
}

message SearchResponse {
  repeated Record records = 1;
  bytes resume_token = 2; // Token to continue from, if more results exist
  bool has_more = 3;

  // Set for pipeline queries (e.g. "error | stats count by level").
  // When present, records is empty; results are in table form.
  TableResult table_result = 4;
}

// TableResult holds aggregated results from a pipeline stats operator.
message TableResult {
  repeated string columns = 1;    // Column names in order (groups first, then aggregates)
  repeated TableRow rows = 2;     // Row data (same column order)
  bool truncated = 3;             // True if cardinality cap was hit
  string result_type = 4;         // "table" or "timeseries" (timeseries when bin() is used)
}

message TableRow {
  repeated string values = 1;
}

message FollowRequest {
  // store field removed - use store=X in query expression instead
  reserved 1;
  reserved "store";
  Query query = 2;
}

message FollowResponse {
  repeated Record records = 1;
}

message ExplainRequest {
  // store field removed - use store=X in query expression instead
  reserved 1;
  reserved "store";
  Query query = 2;
}

message ExplainResponse {
  repeated ChunkPlan chunks = 1;
  string direction = 2;    // "forward" or "reverse"
  int32 total_chunks = 3;  // Total chunks before time-range filtering
  string expression = 4;   // Parsed boolean expression (from BoolExpr.String())
  google.protobuf.Timestamp query_start = 5; // Resolved query start time
  google.protobuf.Timestamp query_end = 6;   // Resolved query end time
}

message Query {
  google.protobuf.Timestamp start = 1;
  google.protobuf.Timestamp end = 2;
  repeated string tokens = 3;
  repeated KVPredicate kv_predicates = 4;
  int64 limit = 5;
  int32 context_before = 6;
  int32 context_after = 7;

  // Raw query expression string, parsed server-side via querylang.
  // When set, tokens and kv_predicates are ignored.
  // Supports the full query language: bare words (tokens), key=value,
  // AND/OR/NOT, parentheses, start=/end=/limit= control args.
  // Examples: "error timeout", "(error OR warn) AND NOT debug",
  //           "start=2024-01-01T00:00:00Z level=error store=prod"
  string expression = 8;
}

message KVPredicate {
  string key = 1;   // Empty for value-exists check
  string value = 2; // Empty for key-exists check, "*" also means any
}

message Record {
  google.protobuf.Timestamp ingest_ts = 1;
  google.protobuf.Timestamp write_ts = 2;
  map<string, string> attrs = 3;
  bytes raw = 4;
  RecordRef ref = 5;
  google.protobuf.Timestamp source_ts = 6;
}

message RecordRef {
  string chunk_id = 1;
  uint64 pos = 2;
  string store_id = 3; // Store this record belongs to
}

// ResumeToken encodes pagination state for multi-store queries.
// The positions array tracks the last returned position for each store/chunk.
message ResumeToken {
  repeated StorePosition positions = 1;
}

message StorePosition {
  string store_id = 1;
  string chunk_id = 2;
  uint64 position = 3; // MaxUint64 indicates chunk is exhausted
}

message ChunkPlan {
  string chunk_id = 1;
  bool sealed = 2;
  int64 record_count = 3;
  repeated PipelineStep steps = 4;
  string scan_mode = 5; // "sequential", "index-driven", or "skipped"
  int64 estimated_records = 6;
  repeated string runtime_filters = 7;
  string store_id = 8;
  google.protobuf.Timestamp start_ts = 9;
  google.protobuf.Timestamp end_ts = 10;
  string skip_reason = 11;
  repeated BranchPlan branch_plans = 12;
}

message BranchPlan {
  string expression = 1;          // String representation of the branch
  repeated PipelineStep steps = 2;
  bool skipped = 3;
  string skip_reason = 4;
  int64 estimated_records = 5;
}

message PipelineStep {
  string name = 1;
  int64 input_estimate = 2;
  int64 output_estimate = 3;
  string action = 4; // "seek", "indexed", "runtime", "skipped"
  string reason = 5;
  string detail = 6;
  string predicate = 7; // What we're filtering for, e.g. "token(error, warn)"
}

message GetContextRequest {
  RecordRef ref = 1;   // The anchor record
  int32 before = 2;    // Number of records before anchor (default 5, max 50)
  int32 after = 3;     // Number of records after anchor (default 5, max 50)
}

message GetContextResponse {
  repeated Record before = 1;  // Records before anchor, oldest first, all stores
  Record anchor = 2;           // The anchor record itself
  repeated Record after = 3;   // Records after anchor, oldest first, all stores
}

message GetSyntaxRequest {}

message GetSyntaxResponse {
  repeated string directives = 1;       // Query control args (reverse, start, end, last, ...)
  repeated string pipe_keywords = 2;    // Pipe operator keywords (stats, where)
  repeated string pipe_functions = 3;   // Functions usable in pipe expressions (count, avg, bin, ...)
}
