syntax = "proto3";

package gastrolog.v1;

option go_package = "gastrolog/api/gen/gastrolog/v1;gastrologv1";

import "google/protobuf/timestamp.proto";

// QueryService provides log querying capabilities.
service QueryService {
  // Search executes a query and streams matching records.
  rpc Search(SearchRequest) returns (stream SearchResponse);

  // Follow executes a query and streams matching records, then continues
  // streaming new records as they arrive (like tail -f).
  rpc Follow(FollowRequest) returns (stream FollowResponse);

  // Explain returns the query execution plan without executing.
  rpc Explain(ExplainRequest) returns (ExplainResponse);

  // Histogram returns record counts bucketed by time for the given query.
  // Uses binary search on chunk indexes for O(buckets * log(n)) performance.
  rpc Histogram(HistogramRequest) returns (HistogramResponse);
}

message SearchRequest {
  // store field removed - use store=X in query expression instead
  reserved 1;
  reserved "store";
  Query query = 2;
  bytes resume_token = 3; // Opaque token for pagination
}

message SearchResponse {
  repeated Record records = 1;
  bytes resume_token = 2; // Token to continue from, if more results exist
  bool has_more = 3;
}

message FollowRequest {
  // store field removed - use store=X in query expression instead
  reserved 1;
  reserved "store";
  Query query = 2;
}

message FollowResponse {
  repeated Record records = 1;
}

message ExplainRequest {
  // store field removed - use store=X in query expression instead
  reserved 1;
  reserved "store";
  Query query = 2;
}

message ExplainResponse {
  repeated ChunkPlan chunks = 1;
  string direction = 2;    // "forward" or "reverse"
  int32 total_chunks = 3;  // Total chunks before time-range filtering
  string expression = 4;   // Parsed boolean expression (from BoolExpr.String())
}

message Query {
  google.protobuf.Timestamp start = 1;
  google.protobuf.Timestamp end = 2;
  repeated string tokens = 3;
  repeated KVPredicate kv_predicates = 4;
  int64 limit = 5;
  int32 context_before = 6;
  int32 context_after = 7;

  // Raw query expression string, parsed server-side via querylang.
  // When set, tokens and kv_predicates are ignored.
  // Supports the full query language: bare words (tokens), key=value,
  // AND/OR/NOT, parentheses, start=/end=/limit= control args.
  // Examples: "error timeout", "(error OR warn) AND NOT debug",
  //           "start=2024-01-01T00:00:00Z level=error store=prod"
  string expression = 8;
}

message KVPredicate {
  string key = 1;   // Empty for value-exists check
  string value = 2; // Empty for key-exists check, "*" also means any
}

message Record {
  google.protobuf.Timestamp ingest_ts = 1;
  google.protobuf.Timestamp write_ts = 2;
  map<string, string> attrs = 3;
  bytes raw = 4;
  RecordRef ref = 5;
}

message RecordRef {
  bytes chunk_id = 1; // 16-byte UUID
  uint64 pos = 2;
  string store_id = 3; // Store this record belongs to
}

// ResumeToken encodes pagination state for multi-store queries.
// The positions array tracks the last returned position for each store/chunk.
message ResumeToken {
  repeated StorePosition positions = 1;
}

message StorePosition {
  string store_id = 1;
  bytes chunk_id = 2; // 16-byte UUID
  uint64 position = 3; // MaxUint64 indicates chunk is exhausted
}

message ChunkPlan {
  bytes chunk_id = 1;
  bool sealed = 2;
  int64 record_count = 3;
  repeated PipelineStep steps = 4;
  string scan_mode = 5; // "sequential", "index-driven", or "skipped"
  int64 estimated_records = 6;
  repeated string runtime_filters = 7;
  string store_id = 8;
  google.protobuf.Timestamp start_ts = 9;
  google.protobuf.Timestamp end_ts = 10;
  string skip_reason = 11;
  repeated BranchPlan branch_plans = 12;
}

message BranchPlan {
  string expression = 1;          // String representation of the branch
  repeated PipelineStep steps = 2;
  bool skipped = 3;
  string skip_reason = 4;
  int64 estimated_records = 5;
}

message PipelineStep {
  string name = 1;
  int64 input_estimate = 2;
  int64 output_estimate = 3;
  string action = 4; // "seek", "indexed", "runtime", "skipped"
  string reason = 5;
  string detail = 6;
  string predicate = 7; // What we're filtering for, e.g. "token(error, warn)"
}

message HistogramRequest {
  google.protobuf.Timestamp start = 1;
  google.protobuf.Timestamp end = 2;
  int32 buckets = 3; // Number of time buckets (default 50 if 0)
  string expression = 4; // Optional: only used to extract store= filter
}

message HistogramResponse {
  repeated HistogramBucket buckets = 1;
  google.protobuf.Timestamp start = 2; // Actual start of histogram range
  google.protobuf.Timestamp end = 3;   // Actual end of histogram range
}

message HistogramBucket {
  google.protobuf.Timestamp ts = 1; // Bucket start time
  int64 count = 2;                  // Record count in this bucket
}
